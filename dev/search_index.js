var documenterSearchIndex = {"docs":
[{"location":"#GeometricIntegrators.jl","page":"Home","title":"GeometricIntegrators.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia library of geometric integrators for differential equations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: PkgEval Status) (Image: CI) (Image: Build Status) (Image: Coverage Status) (Image: codecov Status) (Image: DOI)","category":"page"},{"location":"","page":"Home","title":"Home","text":"GeometricIntegrators.jl is a library of geometric integrators for ordinary differential equations, stochastic differential equations and differential algebraic equations in Julia. Its main purpose is the democratization and proliferation of geometric integrators by providing a comprehensive collection of structure-preserving as well as standard algorithms under a unified interface.  GeometricIntegrators.jl can be used either interactively or as computational core in other codes. It provides both, a high-level interface that requires only very few lines of code to solve an actual problem, and a lean low-level interface that allows for straightforward integration into application codes via the exchange of minimalistic data structures. In both, the library leaves maximum control to the user. While trying to pick sensible defaults, all settings are accessible to and modifiable by the user. Suitable abstraction layers allow to choose between different linear and nonlinear solvers, auto-differentiation packages or custom routines for the computation of Jacobians and the like.","category":"page"},{"location":"#Statement-of-need","page":"Home","title":"Statement of need","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Differential equations are ubiquitous in science and engineering. Many equations possess geometric features or abstract mathematical structures that need to be preserved in the discretisation in order to obtain reliable simulation results, especially for nonlinear problems and long-time simulations. The preservation of such properties improves stability, bounds global error growth and reduces numerical artefacts. Robust, performant and structure-preserving solvers for different types of differential equations are thus needed across many disciplines. GeometricIntegrators.jl provides such solvers and makes them available for both direct use as well as integration into other codes. Furthermore, the implemented algorithms can also be used within the DifferentialEquations.jl ecosystem [Christopher Rackauckas , Qing Nie  (2017)], which is the defacto standard differential equation solver for the Julia programming language [Jeff Bezanson , Alan Edelman , Stefan Karpinski , Viral B. Shah  (2017)].","category":"page"},{"location":"","page":"Home","title":"Home","text":"GeometricIntegrators.jl provides a comprehensive library of existing geometric integration as well as non-geometric algorithms, such as explicit, implicit, partitioned and stochastic Runge-Kutta methods, SPARK methods, splitting methods, symplectic methods and variational integrators. Most methods are implemented in an abstract way that allows for the flexible choice of tableaus, approximation spaces, basis functions, quadrature rules, and thus order of convergence. GeometricIntegrators.jl also serves as a testbed for the development and analysis of novel algorithms. Due to the modular structure and the use of the multiple dispatch paradigm, the library can easily be extended, e.g., towards new algorithms or new types of equations. The library is designed to minimize overhead and maximize performance in order to be able to perform simulations with millions or even billions of time steps to facilitate the study of the long-time behaviour of both numerical algorithms and dynamical systems.","category":"page"},{"location":"#Other-Software","page":"Home","title":"Other Software","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package closely related to GeometricIntegrators.jl is DifferentialEquations.jl [Christopher Rackauckas , Qing Nie  (2017)]. However, the scope of the two libraries is rather different. While DifferentialEquations.jl provides a feature-rich ecosystem for the solution of differential equations, the focus of GeometricIntegrators.jl is on algorithms. In fact, GeometricIntegrators.jl can be used as backend for DifferentialEquations.jl via GeometricIntegratorsDiffEq.jl.","category":"page"},{"location":"#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"tutorial/tutorial.md\",\n         \"integrators.md\",\n]","category":"page"},{"location":"#Modules","page":"Home","title":"Modules","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"modules/equations.md\",\n         \"modules/integrators.md\",\n         \"modules/interpolation.md\",\n         \"modules/discontinuities.md\",\n         \"modules/simulations.md\",\n         \"modules/solutions.md\",\n]","category":"page"},{"location":"#Tableaus","page":"Home","title":"Tableaus","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"tableaus/rungekutta.md\",\n         \"tableaus/prk.md\",\n         \"tableaus/splitting.md\",\n         \"tableaus/vprk.md\",\n         \"tableaus/spark.md\",\n]","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use GeometricIntegrators.jl in your work, please consider citing it by","category":"page"},{"location":"","page":"Home","title":"Home","text":"@misc{Kraus:2020:GeometricIntegrators,\n  title={GeometricIntegrators.jl: Geometric Numerical Integration in Julia},\n  author={Kraus, Michael},\n  year={2020},\n  howpublished={\\url{https://github.com/JuliaGNI/GeometricIntegrators.jl}},\n  doi={10.5281/zenodo.3648325}\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"GeometricIntegrators.jl contains reference implementation for the methods described in the following articles:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Michael Kraus. Hamilton-Pontryagin-Galerkin Integrators.\nMichael Kraus. Projected Variational Integrators for Degenerate Lagrangian Systems. arXiv:1708.07356.\nMichael Kraus. SPARK Methods for Degenerate Lagrangian Systems.\nMichael Kraus. SPARK Methods for Hamiltonian Systems subject to Dirac Constraints.\nMichael Kraus. Symplectic Runge-Kutta Methods for Degenerate Lagrangian Systems.\nMichael Kraus. Variational Integrators for Noncanonical Hamiltonian Systems.\nMichael Kraus and Tomasz M. Tyranowski. Variational Integrators for Stochastic Dissipative Hamiltonian Systems. arXiv:1909.07202, Journal.\nMichael Kraus, Joshua Burby. Conservation of Poincaré Integral Invariants in Numerical Simulations.","category":"page"},{"location":"#Background-Material","page":"Home","title":"Background Material","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Ernst Hairer and Christian Lubich. Numerical Solution of Ordinary Differential Equations. The Princeton Companion to Applied Mathematics, 293-305, 2015. Princeton University Press. (Author's Web Site)\nErnst Hairer, Christian Lubich and Gerhard Wanner. Geometric Numerical Integration Illustrated by the Störmer–Verlet Method. Acta Numerica 12, 399-450, 2003. (Journal)\nLaurent O. Jay. Lobatto Methods. Encyclopedia of Applied and Computational Mathematics, 817–826. Springer, 2015. (Article)","category":"page"},{"location":"#Books-on-Geometric-Numerical-Integration","page":"Home","title":"Books on Geometric Numerical Integration","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Sergio Blanes, Fernando Casas. A Concise Introduction to Geometric Numerical Integration. CRC Press, 2016. (eBook)\nErnst Hairer, Christian Lubich and Gerhard Wanner. Geometric Numerical Integration. Springer, 2006. (eBook)\nBenedict Leimkuhler and Sebastian Reich. Simulating Hamiltonian Dynamics. Cambridge University Press, 2005. (eBook)\nJesús Maria Sanz-Serna, Manuel P. Calvo. Numerical Hamiltonian Problems. Chapman Hall, 1994.","category":"page"},{"location":"#Books-on-the-Numerical-Integration-of-Differential-Equations","page":"Home","title":"Books on the Numerical Integration of Differential Equations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Ernst Hairer, Syvert P. Nørsett and Gerhard Wanner. Solving Ordinary Differential Equations I: Nonstiff Problems. Springer, 1993. (eBook)\nErnst Hairer and Gerhard Wanner. Solving Ordinary Differential Equations II: Stiff and Differential-Algebraic Problems. Springer, 1996. (eBook)\nErnst Hairer, Christian Lubich, Michel Roche. The Numerical Solution of Differential-Algebraic Systems by Runge-Kutta Methods. Springer, 1989. (eBook)\nPeter Deuflhard, Folkmar Bornemann. Scientific Computing with Ordinary Differential Equations. Springer, 2002. (eBook)\nJohn C. Butcher. Numerical Methods for Ordinary Differential Equations. Wiley, 2016. (eBook)","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Copyright (c) Michael Kraus <michael.kraus@ipp.mpg.de>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"CurrentModule = GeometricIntegrators","category":"page"},{"location":"integrators/#Integrators","page":"Overview","title":"Integrators","text":"","category":"section"},{"location":"integrators/","page":"Overview","title":"Overview","text":"GeometricIntegrators.jl provides a plethora of geometric and non-geometric integrators. Most integrators are specified by a tableau, that is a Butcher tableau for Runge-Kutta methods, a pair of tableaus for partitioned Runge-Kutta and VPRK methods, or generalizations thereof for SPARK methods. Other integrators, such as Galerkin variational integrators require the specification of a basis and a quadrature rule.","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"In many cases, the correct integrator is automatically selected based on the tableau and equation types by calling","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"Integrator(equation, tableau, Δt)","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"where Δt is the time step.","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"As an example, consider an ODE like the harmonic oscillator, which is included in GeometricProblems.jl:","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"using GeometricIntegrators\nusing GeometricProblems.HarmonicOscillator","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"ode = harmonic_oscillator_ode()","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"Create an explicit Euler tableau:","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"tab = TableauExplicitEuler()","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"And now create an Integrator with the general Integrator constructor:","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"int = Integrator(ode, tab, 0.1)","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"We see that we obtained an IntegratorERK, i.e., an explicit Runge-Kutta integrator. If instead we choose the implicit Euler tableau:","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"tab = TableauImplicitEuler()","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"the general Integrator constructor creates a different integrator:","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"int = Integrator(ode, tab, 0.1)","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"namely an IntegratorFIRK, i.e., a fully implicit Runge-Kutta integrator.","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"This is possible because most integrators come with a dedicated tableau type, so that Integrator can dispatch on that.","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"In some cases, in particular the VPRK integrators, the integrator has to be explicitly specified as there are different integrators that use the same tableau type and operate on the same equation type, here TableauVPRK and IODE. Consider again the harmonic oscillator:","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"using GeometricIntegrators\nusing GeometricProblems.HarmonicOscillator","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"iode = harmonic_oscillator_iode()","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"Create a VPRK tableau that uses Gauss-Legendre Runge-Kutta coefficients with two stages:","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"tab = TableauVPGLRK(2)","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"If we just call the Integrator constructor,","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"int = Integrator(iode, tab, 0.1)","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"we obtain a plain IntegratorVPRK. If we want to use any of the projection methods, we have to explicitly specify the corresponding integrator type:","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"using GeometricIntegrators.Integrators.VPRK\nint = IntegratorVPRKpStandard(iode, tab, 0.1)","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"or","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"int = IntegratorVPRKpSymmetric(iode, tab, 0.1)","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"Once an integrator is obtained, we can just call the function","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"integrate(equation, integrator, ntime)","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"to perform the actual integration steps, where ntime defines the number of steps to integrate:","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"using GeometricIntegrators\nusing GeometricProblems.HarmonicOscillator\node = harmonic_oscillator_ode()","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"tab = TableauExplicitEuler()\nint = Integrator(ode, tab, 0.1)\nsol = integrate(ode, int, 100)","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"The integrate function returns a solution object that stores the solution for each of the ntime time steps. There is also a convenience function that combines all of the above steps in one single call, namely","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"integrate(equation, tableau, Δt, ntime)","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"If the solution object is created manually, there exists a function","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"integrate!(integrator, solution)","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"that operates on an existing solution.","category":"page"},{"location":"tableaus/rungekutta/#Runge-Kutta-Tableaus","page":"Runge-Kutta Methods","title":"Runge-Kutta Tableaus","text":"","category":"section"},{"location":"tableaus/rungekutta/","page":"Runge-Kutta Methods","title":"Runge-Kutta Methods","text":"Modules = [RungeKutta]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"tableaus/rungekutta/#RungeKutta.PartitionedTableau","page":"Runge-Kutta Methods","title":"RungeKutta.PartitionedTableau","text":"Tableau of a Partitioned Runge-Kutta method\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij  v(t_n + c_j Delta t Q_nj P_nj)  \nq_n+1 = q_n + h sum limits_i=1^s b_i   v(t_n + c_j Delta t Q_ni P_ni)  \nP_ni = p_n + h  sum limits_i=1^s bara_ij  f(t_n + c_j Delta t Q_nj P_nj)  \np_n+1 = p_n + h sum limits_i=1^s barb_i    f(t_n + c_j Delta t Q_ni P_ni) \nendaligned\n\nParameters:\n\nT: datatype of coefficient arrays\n\nFields:\n\nname: symbolic name of the tableau\no: order of the method\ns: number of stages\nq: Tableau for q\np: Tableau for p\n\nThe actual tableaus are stored in q and p:\n\na: coefficients a_ij with $ 1 \\le i,j \\le s$\nb: weights b_i  with $ 1 \\le i \\le s$\nc: nodes c_i  with $ 1 \\le i \\le s$\n\nConstructors:\n\nPartitionedTableau{T}(name, o, s, q, p)\nPartitionedTableau{T}(name, q, p)\nPartitionedTableau(name::Symbol, q::Tableau, p::Tableau)\nPartitionedTableau(name::Symbol, q::Tableau)\n\n\n\n\n\n","category":"type"},{"location":"tableaus/rungekutta/#RungeKutta.Tableau","page":"Runge-Kutta Methods","title":"RungeKutta.Tableau","text":"Holds the tableau of a Runge-Kutta method\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij  v(t_n + c_j Delta t Q_nj)  \nq_n+1 = q_n + h sum limits_i=1^s b_i   v(t_n + c_j Delta t Q_ni)  \nendaligned\n\nParameters:\n\nT: datatype of coefficient arrays\n\nFields:\n\nname: symbolic name of the tableau\no: order of the method\ns: number of stages\na: coefficients a_ij with $ 1 \\le i,j \\le s$\nb: weights b_i  with $ 1 \\le i \\le s$\nc: nodes c_i  with $ 1 \\le i \\le s$\n\nConstructors:\n\nTableau{T}(name, o, s, a, b, c)\nTableau{T}(name, o, a, b, c)\nTableau(name::Symbol, o::Int, s::Int, a::AbstractMatrix, b::AbstractVector, c::AbstractVector)\nTableau(name::Symbol, o::Int, a::AbstractMatrix, b::AbstractVector, c::AbstractVector)\nTableau(name::Symbol, o::Int, t::AbstractMatrix)\n\nThe last constructor accepts an (s+1) times (s+1) array that holds the whole tableau in the form of a Butcher tableau, i.e.,\n\nc a\n b\n\n\n\n\n\n","category":"type"},{"location":"tableaus/rungekutta/#Base.show-Tuple{IO,MIME{Symbol(\"text/markdown\")},Tableau}","page":"Runge-Kutta Methods","title":"Base.show","text":"Base.show(io::IO, ::MIME\"text/markdown\", tab::Tableau)\n\nGenerate and print a nice markdown table for the Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#Base.show-Tuple{IO,Tableau}","page":"Runge-Kutta Methods","title":"Base.show","text":"Base.show(io::IO, tab::Tableau)\n\nPretty-print Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta._legendre-Union{Tuple{T}, Tuple{Int64,T}} where T","page":"Runge-Kutta Methods","title":"RungeKutta._legendre","text":"Legendre polynomial P_s(x) of degree s defined on the interval [-1..+1].\n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta._shifted_legendre","page":"Runge-Kutta Methods","title":"RungeKutta._shifted_legendre","text":"Legendre polynomial of degree s shifted to the interval [0..1], i.e., P_s(2x-1).\n\n\n\n\n\n","category":"function"},{"location":"tableaus/rungekutta/#RungeKutta.from_file-Tuple{AbstractString,AbstractString}","page":"Runge-Kutta Methods","title":"RungeKutta.from_file","text":"from_file(dir::AbstractString, name::AbstractString)\n\nRead Runge-Kutta tableau from the file <name>.tsv in the directory dir.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.solve_simplifying_assumption_b-Union{Tuple{AbstractArray{T,1}}, Tuple{T}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.solve_simplifying_assumption_b","text":"Compute the weights by solving the simplifying assumption B(s):\n\nsum limits_j=1^s b_j c_j^k-1 = frac1k  qquad k = 1      s \n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.solve_simplifying_assumption_c-Union{Tuple{AbstractArray{T,1}}, Tuple{T}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.solve_simplifying_assumption_c","text":"Compute the coefficients by solving the simplifying assumption C(s):\n\nsum limits_j=1^s a_ij c_j^k-1 = fracc_i^kk  qquad i = 1      s   k = 1      s \n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.solve_simplifying_assumption_d-Union{Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,1}}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.solve_simplifying_assumption_d","text":"Compute the coefficients by solving the simplifying assumption D(s):\n\nsum limits_i=1^s b_i c_i^k-1 a_ij = fracb_jk ( 1 - c_j^k)  qquad j = 1      s   k = 1      s \n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.to_file-Union{Tuple{T}, Tuple{AbstractString,Tableau{T}}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.to_file","text":"to_file(dir::AbstractString, tab::Tableau)\n\nWrite Runge-Kutta tableau to the file <tab.name>.tsv in the directory dir.\n\n\n\n\n\n","category":"method"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"CurrentModule = GeometricIntegrators.Tableaus","category":"page"},{"location":"integrators/rk/#Runge-Kutta-Methods","page":"Runge-Kutta","title":"Runge-Kutta Methods","text":"","category":"section"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Runge-Kutta methods exploit the Fundamental Theorem of Calculus, which states that the solution of an initial-value problem","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"beginaligned\ndotx (t) = f(t x(t))  \nx(t_n) = x_n \nendaligned","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"at time t_n+1 is given by","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"x (t_n+1) = x (t_n) + int limits_t_n^t_n+1 dotx (t)  dt ","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Runge-Kutta methods are constructed by approximating the integral by some quadrature formula with s nodes c_i and corresponding weights b_i to obtain x_n+1 approx x (t_n+1) by","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"beginaligned\nx_n+1 = x_n + h sum limits_i=1^s b_i dotX_ni  \ndotX_ni = f(t_n + c_i h X_ni) \nendaligned","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"where the internal stage values X_ni approx x(t_n + c_i h) for i = 1  s are determined by another quadrature formula, approximating the integral","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"x(t_n + c_i h) = x (t_n) + int limits_t_n^t_n + c_i h dotx (t)  dt ","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"namely","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"X_ni = x_n + h sum limits_j=1^s a_ij dotX_nj ","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"with the same vector field values dotX_nj used for the computation of x_n+1.","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Definition: Runge-Kutta methods are numerical one-step methods","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"beginaligned\nX_ni = x_n + h sum limits_j=1^s a_ij  f(t_n + c_j h X_nj)  \nx_n+1 = x_n + h sum limits_j=1^s b_j   f(t_n + c_j h X_nj) \nendaligned","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"defined by a set of nodes c_i, weights b_i and coefficients a_ij with ij = 1  s, summarized in the Butcher tableau","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"beginarraycc\nc  a     \nhline\n   b^T \nendarray\n=\nbeginarrayccccc\nc_1   a_11  a_12  dots  a_1s \nc_2   a_21  a_22  dots  a_2s \nvdots  vdots  vdots  ddots  vdots \nc_s   a_s1  a_s2  dots  a_ss \nhline\n        b_1   b_2   dots  b_s  \nendarray","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Most properties of the methods, such as order or stability, can be analysed just by posing conditions on the Butcher tableau.","category":"page"},{"location":"integrators/rk/#Common-Runge-Kutta-Methods","page":"Runge-Kutta","title":"Common Runge-Kutta Methods","text":"","category":"section"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"GeometricIntegrators.jl provides various explicit and implicit (both diagonally and fully implicit) Runge-Kutta methods. For many methods, tabulated coefficients are included, namely","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Function and Aliases Stages Order\nExplicit Methods  \nTableauExplicitEuler, TableauForwardEuler 1 1\nTableauExplicitMidpoint 2 2\nTableauHeun2 2 2\nTableauHeun3 3 3\nTableauKutta, TableauKutta3 3 3\nTableauRalston2 2 2\nTableauRalston3 3 3\nTableauRunge, TableauRunge2 2 2\nTableauRK416, TableauRK4 4 4\nTableauRK438 4 4\nTableauSSPRK3 3 3\nDiagonally Implicit Methods  \nTableauCrankNicolson 2 2\nTableauCrouzeix 2 3\nTableauKraaijevangerSpijker 2 2\nTableauQinZhang 2 2\nFully Implicit Methods  \nTableauImplicitEuler, TableauBackwardEuler 1 1\nTableauImplicitMidpoint 2 2\nTableauSRK3 3 4","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"The coefficients of other methods are computed on-the-fly as described in the following.","category":"page"},{"location":"integrators/rk/#Simplifying-Assumptions","page":"Runge-Kutta","title":"Simplifying Assumptions","text":"","category":"section"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"The construction of many Runge-Kutte methods, in particular the Gauß, Radau and Lobatto methods, relies on the so-called simplifying assumptions:","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"beginaligned\nB(sigma)  sum limits_i=1^s b_i c_i^k-1 = frac1k  \nk = 1      sigma  \n\nC(eta)  sum limits_j=1^s a_ij c_j^k-1 = fracc_i^kk  \ni = 1     s   k = 1      eta  \n\nD(zeta)  sum limits_i=1^s b_i c_i^k-1 a_ij = fracb_jk ( 1 - c_j^k )  \nj = 1     s   k = 1      zeta \nendaligned","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"These assumptions provide order conditions for a Runge-Kutta method given by (a_ij b_i c_i). The condition B(p) implies that the quadrature rule (b_i c_i) is of order p. Furthermore, the following theorem holds:","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Theorem (Butcher 1964): If the coefficients (a_ij b_i c_i) of a Runge-Kutta method satisfy B(sigma), C(eta), D(zeta) with sigma le eta + zeta + 1 and sigma le 2 eta + 2, then the method is of order sigma.","category":"page"},{"location":"integrators/rk/#Gauß,-Lobatto-and-Radau-Methods","page":"Runge-Kutta","title":"Gauß, Lobatto and Radau Methods","text":"","category":"section"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Gauß methods are collocation methods using the nodes and weights of Gaußian quadrature formulas. The nodes are the zeros of the shifted Legendre polynomials of degree s,","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"fracd^sdx^s big( x^s (x-1)^s big) ","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"In a similar fashion, the nodes of the Radau I and II and the Lobatto III methods are defined as the roots of the polynomials","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"beginaligned\n fracd^s-1dx^s-1 big( x^s (x-1)^s-1 big)      text(Radau I)  \n fracd^s-1dx^s-1 big( x^s-1 (x-1)^s big)      text(Radau II)  \n fracd^s-2dx^s-2 big( x^s-1 (x-1)^s-1 big)  text(Lobatto III) \nendaligned","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"The weights b_1  b_s are chosen such that the methods satisfy B(sigma), that is B(s), for the Gauß methods, B(s-1) for the Radau methods, and B(s-2) for the Lobatto methods.","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"The coefficients a_ij for ij = 1  s are obtained by the simplifying assumption C(s) for the Gauß, Radau IIA and Lobatto IIIA methods, and by the simplifying assumption D(s) for the Radau IA and Lobatto IIIB methods. The coefficients of the Lobatto IIIC methods are determined by setting a_i1 = b_1 for i = 1  s and solving the simplifying assumption C(s-1), while the coefficients of the Lobatto IIIC̄ methods are determined by setting a_is = 0 and solving C(s-1). Note that the Lobatto IIIC̄ methods are sometimes also called Lobatto III or Lobatto III*. For reasons of code symmetry we chose to stick with the less common name Lobatto IIIC̄. The Lobatto IIID and IIIE methods are obtained by combining the tableaus of the Lobatto IIIC and IIIC̄ and the Lobatto IIIA and IIIB methods, respectively, i.e., ","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"beginaligned\na_ij^D = tfrac12 ( a_ij^C + a_ij^C ) \n textand \na_ij^E = tfrac12 ( a_ij^A + a_ij^B ) \nendaligned","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"While the Lobatto IIIA, IIIB, IIIC and IIIC̄ methods are not symplectic on their own (although the Lobatto IIIA-IIIB and IIIC-IIIC̄ pairs constitute symplectic partitioned Runge-Kutta methods), the Lobatto IIID and IIIE methods are each symplectic by themselves.","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"The Gauß methods are of order 2s, the Radau methods or order 2s-1 and the Lobatto methods are of order 2s-2, with the exception of the Lobatto IIIF method. This method has been specifically constructed to be of order 2s as described in [Wang Fangzong , Liao Xiaobing  (2016)]. The Lobatto IIIG method is constructed in a similar fashion as the Lobatto IIID and IIIE methods by averaging the coefficients of the Lobatto IIIF method with its symplectic complement, i.e.,","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"a_ij^G = tfrac12 ( a_ij^F + bara_ij^F ) ","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"where the coffiecients bara_ij^F are determined by","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"beginaligned\nb_i bara^F_ij + barb_j a^F_ji = b_i barb_j  \n textand \nbarb_i = b_i \nendaligned","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"The tableaus of all of the above methods can be computed for an arbitrary number of stages s and thus to arbitrary order.","category":"page"},{"location":"integrators/rk/#Constructors","page":"Runge-Kutta","title":"Constructors","text":"","category":"section"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"The following methods are provided for the construction of the tableaus for the previously described methods:","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Function Method\nTableauGauss(s, T=Float64) Gauß-Legendre with s stages\nTableauLobattoIIIA(s, T=Float64) Lobatto IIIA with s stages\nTableauLobattoIIIB(s, T=Float64) Lobatto IIIB with s stages\nTableauLobattoIIIC(s, T=Float64) Lobatto IIIC with s stages\nTableauLobattoIIIC̄(s, T=Float64) Lobatto IIIC̄ with s stages\nTableauLobattoIIID(s, T=Float64) Lobatto IIID with s stages\nTableauLobattoIIIE(s, T=Float64) Lobatto IIIE with s stages\nTableauLobattoIIIF(s, T=Float64) Lobatto IIIF with s stages\nTableauLobattoIIIG(s, T=Float64) Lobatto IIIG with s stages\nTableauRadauIA(s, T=Float64) Radau IA with s stages\nTableauRadauIB(s, T=Float64) Radau IB with s stages\nTableauRadauIIA(s, T=Float64) Radau IIA with s stages\nTableauRadauIIB(s, T=Float64) Radau IIB with s stages","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"The first argument s refers to the number of stages (s ge 1 for Gauß and s ge 2 for all other methods). The second argument specifies the number type of the coefficients. Internally, all coefficients are computed using BigFloat and then converted to the requested number type, defaulting to Float64.","category":"page"},{"location":"tableaus/prk/#Partitioned-Runge-Kutta-Tableaus","page":"Partitioned Runge-Kutta Methods","title":"Partitioned Runge-Kutta Tableaus","text":"","category":"section"},{"location":"tableaus/prk/","page":"Partitioned Runge-Kutta Methods","title":"Partitioned Runge-Kutta Methods","text":"Modules = [GeometricIntegrators.Tableaus]\nPages   = [\"tableaus/tableaus_eprk.jl\",\n           \"tableaus/tableaus_iprk.jl\"]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"modules/integrators/#Integrators","page":"Integrators","title":"Integrators","text":"","category":"section"},{"location":"modules/integrators/#Common","page":"Integrators","title":"Common","text":"","category":"section"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"Modules = [GeometricIntegrators.Integrators]\nPages   = [\"integrators/abstract_coefficients.jl\",\n           \"integrators/abstract_integrator.jl\",\n           \"integrators/abstract_tableau.jl\",\n           \"integrators/integrator_cache.jl\",\n           \"integrators/integrators_common.jl\",\n           \"integrators/integrators.jl\"]","category":"page"},{"location":"modules/integrators/#GeometricIntegrators.Solutions.AtomicSolution-Tuple{SolutionDAE,Integrator}","page":"Integrators","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Create AtomicSolution for DAE.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Solutions.AtomicSolution-Tuple{SolutionODE,Integrator}","page":"Integrators","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Create AtomicSolution for ODE.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Solutions.AtomicSolution-Tuple{SolutionPDAE,Integrator}","page":"Integrators","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Create AtomicSolution for partitioned DAE.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Solutions.AtomicSolution-Tuple{SolutionPODE,Integrator}","page":"Integrators","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Create AtomicSolution for partitioned ODE.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Tuple{Integrator,AtomicSolution}","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Performs one time step with a given integrator.\n\nintegrate_step!(integrator::Integrator, asol::AtomicSolution)\n\nThe function accepts two arguments: an integrator and an appropriate AtomicSolution, which contains the state of the system at the beginning and the end of the time step and possibly additional information like solver output or the solution at internal stages of a Runge-Kutta method.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.AbstractTableau","page":"Integrators","title":"GeometricIntegrators.Integrators.AbstractTableau","text":"Holds the information for the various methods' tableaus.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.create_internal_stage_matrix-NTuple{4,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.create_internal_stage_matrix","text":"Create a vector of S solution matrices of type DT to store the solution of S internal stages for a problem with DxM dimensions.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.create_internal_stage_vector-Tuple{Any,Any,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.create_internal_stage_vector","text":"Create a vector of S solution vectors of type DT to store the solution of S internal stages for a problem with D dimensions.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.create_internal_stage_vector_with_zero-NTuple{4,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.create_internal_stage_vector_with_zero","text":"Create a vector of (S,M+1) solution vectors of type DT to store the solution of S internal stages and M random processes for a problem with D dimensions.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.create_internal_stage_vector_with_zero-Tuple{Any,Any,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.create_internal_stage_vector_with_zero","text":"Create a vector of S+1 solution vectors of type DT to store the solution of S internal stages and the solution of the previous timestep for a problem with D     dimensions.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.create_nonlinear_solver","page":"Integrators","title":"GeometricIntegrators.Integrators.create_nonlinear_solver","text":"Create nonlinear solver object for a system of N equations with data type DT. The function f(x)=0 to be solved for is determined by a julia function function_stages!(x, b, params), where x is the current solution and b is the output vector, s.th. b = f(x). params are a set of parameters depending on the equation and integrator that is used. The solver type is obtained from the config dictionary (:nls_solver).\n\n\n\n\n\n","category":"function"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{Equation,Union{AbstractTableau, Tableau},Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Print error for integrators not implemented, yet.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{IDAE,GeometricIntegrators.Integrators.SPARK.AbstractTableauSPARK{:spark,DT} where DT<:Number,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for special partitioned additive Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{IDAE,GeometricIntegrators.Integrators.SPARK.AbstractTableauSPARK{:vpark,DT} where DT<:Number,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for variational partitioned additive Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{IDAE,GeometricIntegrators.Integrators.SPARK.AbstractTableauSPARK{:vspark,DT} where DT<:Number,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for variational special partitioned additive Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{IDAE,GeometricIntegrators.Integrators.SPARK.AbstractTableauSPARK{:vspark_primary,DT} where DT<:Number,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for variational special partitioned additive Runge-Kutta tableau with projection on primary constraint.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{IODE,CoefficientsPGLRK,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for Projected Gauss-Legendre Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{IODE,GeometricIntegrators.Integrators.VPRK.TableauVPRK,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for variational partitioned Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{ODE,Tableau,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{PDAE,GeometricIntegrators.Integrators.SPARK.AbstractTableauSPARK{:hpark,DT} where DT<:Number,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for Hamiltonian partitioned additive Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{PDAE,GeometricIntegrators.Integrators.SPARK.AbstractTableauSPARK{:hspark,DT} where DT<:Number,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for Hamiltonian special partitioned additive Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{PDAE,GeometricIntegrators.Integrators.SPARK.AbstractTableauSPARK{:hspark_primary,DT} where DT<:Number,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for Hamiltonian special partitioned additive Runge-Kutta tableau with projection on primary constraint.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{SODE,AbstractTableauSplitting,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for splitting tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{Union{HODE, PODE},PartitionedTableau,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for explicit partitioned Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{Union{IODE, VODE},PartitionedTableau,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for implicit partitioned Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{VDAE,GeometricIntegrators.Integrators.SPARK.TableauVSPARKsecondary,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for variational special partitioned additive Runge-Kutta tableau with projection on secondary constraint.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{VODE,Tableau,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for formal Lagrangian Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorConstructor-Tuple{Any,Any,Tableau}","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorConstructor","text":"Create integrator constructor for Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorConstructor-Tuple{Any,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorConstructor","text":"Create integrator constructor for exact solution.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate!-Tuple{Integrator,Solution,Any,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate!","text":"Integrate ODE for initial conditions m with m₁ ≤ m ≤ m₂.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate!-Tuple{Integrator,Solution}","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate!","text":"Integrate equation for all initial conditions.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate!-Union{Tuple{AT}, Tuple{TT}, Tuple{DT}, Tuple{Integrator{DT,TT},Solution{AT,TT,N} where N,Int64,Int64,Int64,Int64}} where AT<:(AbstractArray{DT,N} where N) where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate!","text":"Integrate ODE for initial conditions m with m₁ ≤ m ≤ m₂ for time steps n with n₁ ≤ n ≤ n₂.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate-Tuple{Equation,Integrator,Int64}","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate","text":"Apply integrator for ntime time steps and return solution.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate-Tuple{Equation,Union{AbstractTableau, PartitionedTableau, Tableau},Any,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate","text":"Integrate given equation with given tableau for ntime time steps and return solution.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate-Tuple{Function,Array{T,1} where T,Union{AbstractTableau, Tableau},Any,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate","text":"Integrate ODE specified by vector field and initial condition with given tableau for ntime time steps and return solution.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate-Tuple{Function,Function,Array{T,1} where T,Array{T,1} where T,Union{AbstractTableau, PartitionedTableau, Tableau},Any,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate","text":"Integrate PODE specified by two vector fields and initial conditions with given tableau for ntime time steps and return solution.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#Initial-Guesses","page":"Integrators","title":"Initial Guesses","text":"","category":"section"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"Modules = [GeometricIntegrators.Integrators]\nPages   = [\"integrators/initial_guess/extrapolation.jl\",\n           \"integrators/initial_guess/initial_guess_ode.jl\",\n           \"integrators/initial_guess/initial_guess_pode.jl\"]","category":"page"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.aitken_neville-Union{Tuple{TT}, Tuple{Array{TT,1},Array{T,2} where T,TT,Array{T,1} where T}} where TT","page":"Integrators","title":"GeometricIntegrators.Integrators.aitken_neville","text":"Compute p(x) where p is the unique polynomial of degree length(xi), such that p(x[i]) = y[i]) for all i.\n\nti: interpolation nodes\nxi: interpolation values\nt:  evaluation point\nx:  evaluation value\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.euler_extrapolation-Union{Tuple{TT}, Tuple{Function,TT,TT,Array{T,1} where T,Array{T,1} where T,Int64}} where TT","page":"Integrators","title":"GeometricIntegrators.Integrators.euler_extrapolation","text":"Euler extrapolation method with arbitrary order p.\n\nv:  function to compute vector field\nt₀: initial time\nt₁: final   time\nx₀: initial value\nx₁: final   value\ns:  number of interpolations (order p=s+1)\n\nTODO This is probably broken!\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.midpoint_extrapolation-Union{Tuple{DT}, Tuple{TT}, Tuple{Function,Function,TT,TT,Array{DT,1},Array{DT,1},Array{DT,1},Array{DT,1},Int64}} where DT where TT","page":"Integrators","title":"GeometricIntegrators.Integrators.midpoint_extrapolation","text":"Midpoint extrapolation method with arbitrary order p.\n\nv:  function to compute vector field\nf:  function to compute force  field\nt₀: initial time\nt₁: final   time\nq₀: initial positions\np₀: initial momenta\nq₁: final   positions\np₁: final   momenta\ns:  number of interpolations (order p=2s+2)\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.midpoint_extrapolation-Union{Tuple{TT}, Tuple{DT}, Tuple{Function,TT,TT,Array{DT,1},Array{DT,1},Int64}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.midpoint_extrapolation","text":"Midpoint extrapolation method with arbitrary order p.\n\nv:  function to compute vector field\nt₀: initial time\nt₁: final   time\nx₀: initial value\nx₁: final   value\ns:  number of interpolations (order p=2s+2)\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.InitialGuessODE","page":"Integrators","title":"GeometricIntegrators.Integrators.InitialGuessODE","text":"InitialGuessODE: Initial guess for ordinary differential equations\n\nFields\n\nint: interpolation structure\nv:   vector  field\nΔt:  time step\ns:   number of extrapolation stages (for initialisation)\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.initialize!-Union{Tuple{TT}, Tuple{DT}, Tuple{InitialGuessODE{TT,VT,IT} where IT<:Interpolator{TT} where VT,TT,Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}},Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}},TT,Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}},Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}}}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.initialize!","text":"Initialise initial guess, i.e., given t₀, t₁, q₁ compute q₀, v₀, v₁.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.update_vector_fields!-Union{Tuple{TT}, Tuple{DT}, Tuple{InitialGuessODE{TT,VT,IT} where IT<:Interpolator{TT} where VT,TT,Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}},Array{DT,1}}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.update_vector_fields!","text":"compute vector field of new solution\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.InitialGuessPODE","page":"Integrators","title":"GeometricIntegrators.Integrators.InitialGuessPODE","text":"InitialGuessPODE: Initial guess for partitioned ordinary differential equations\n\nFields\n\nint: interpolation structure\nv:   vector field for q\nf:   vector field for p\nΔt:  time step\ns:   number of extrapolation stages (for initialisation)\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.initialize!-Union{Tuple{TT}, Tuple{DT}, Tuple{InitialGuessPODE{TT,VT,FT,IT} where IT<:Interpolator{TT} where FT where VT,TT,Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}},Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}},Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}},Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}},TT,Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}},Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}},Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}},Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}}}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.initialize!","text":"Initialise initial guess, i.e., given t₀, t₁, q₁ compute q₀, v₀, v₁.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#Splitting-Methods","page":"Integrators","title":"Splitting Methods","text":"","category":"section"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"Modules = [GeometricIntegrators.Integrators]\nPages   = [\"integrators/splitting/integrators_composition.jl\",\n           \"integrators/splitting/integrators_splitting.jl\",\n           \"integrators/splitting/integrators_exact_ode.jl\",\n           \"integrators/splitting/splitting_tableau.jl\"]","category":"page"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorComposition","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorComposition","text":"Composition integrator for the solution of initial value problems\n\ndotq (t) = v(t q(t))  qquad q(t_0) = q_0 \n\nwhose vector field v is given as a sum of vector fields\n\nv (t) = v_1 (t) +  + v_r (t) \n\nIntegratorComposition has three constructors:\n\nIntegratorComposition{DT,D}(integrators::Tuple, Δt)\nIntegratorComposition(equation::SODE, constructors::Tuple, tableau::AbstractTableauSplitting, Δt)\nIntegratorComposition(equation::SODE, tableau::AbstractTableauSplitting, Δt)\n\nIn the first constructor, DT is the data type of the state vector and D the dimension of the system. In the second and third constructor, this information is extracted from the equation.  The tuple integrators contains the integrators for each substep. Each integrator is instantiated with appropriately scaled time step size Delta t = c_i tau to match the corresponding splitting scheme. In the second constructor, the tuple constructors contains constructors for the integrators of each step of the composition. The integrators are constructed according to the tableau and time step \\Delta t and passed to the first constructor. The third constructor assumes that the exact solution is used for each splitting step. It thus constructs a composition method that is equivalent to a plain IntegratorSplitting.\n\nIn order to include exact solutions in the composition, the IntegratorExactODE implements the general integrator interface.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorSplitting","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorSplitting","text":"Splitting integrator for the solution of initial value problems\n\ndotq (t) = v(t q(t))  qquad q(t_0) = q_0 \n\nwhose vector field v is given as a sum of vector fields\n\nv (t) = v_1 (t) +  + v_r (t) \n\nIntegratorSplitting has two constructors:\n\nIntegratorSplitting{DT,D}(solutions::Tuple, f::Vector{Int}, c::Vector, Δt)\nIntegratorSplitting(equation::SODE, tableau::AbstractTableauSplitting, Δt)\n\nIn the first constructor, DT is the data type of the state vector and D the dimension of the system. In the second constructor, this information is extracted from the equation.  The tuple solutions contains functions implementing the flow (exact solution) of the vector fields v_i. The vectors f and c define the actual splitting method: f is a vector of indices of the flows in the split equation to be solved and c is a vector of the same size f that contains the coefficients for each splitting step, i.e., the resulting integrator has the form\n\nvarphi_tau = phi_cs tau^v_fs circ dotsc circ phi_c2 tau^v_f2 circ phi_c1 tau^v_f1 \n\nIn the second constructor, these vectors are constructed from the tableau and the equation.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorExactODE","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorExactODE","text":"Exact solution of an ODE.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.TableauSplitting","page":"Integrators","title":"GeometricIntegrators.Integrators.TableauSplitting","text":"Tableau for general splitting methods for vector fields with two components A and B.\n\nIntegrator:\n\nvarphi_tau = varphi_b_s tau^B circ varphi_a_s tau^A circ dotsc circ varphi_b_1 tau^B circ varphi_a_1 tau^A\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.TableauSplittingGS","page":"Integrators","title":"GeometricIntegrators.Integrators.TableauSplittingGS","text":"Tableau for symmetric splitting methods with general stages.     See McLachlan, Quispel, 2003, Equ. (4.11).\n\nBasic method: Lie composition\n\nbeginaligned\nvarphi_tau^A = varphi_tau^v_1 circ varphi_tau^v_2 circ dotsc circ varphi_tau^v_r-1 circ varphi_tau^v_r \nvarphi_tau^B = varphi_tau^v_r circ varphi_tau^v_r-1 circ dotsc circ varphi_tau^v_2 circ varphi_tau^v_1\nendaligned\n\nIntegrator:\n\nvarphi_tau^GS = varphi_a_1 tau^A circ varphi_b_1 tau^B circ dotsc circ varphi_b_1 tau^B circ varphi_a_1 tau^A\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.TableauSplittingNS","page":"Integrators","title":"GeometricIntegrators.Integrators.TableauSplittingNS","text":"Tableau for non-symmetric splitting methods.     See McLachlan, Quispel, 2003, Equ. (4.10).     The methods A and B are the composition of all vector fields in the SODE     and its adjoint, respectively.\n\nBasic method: Lie composition\n\nbeginaligned\nvarphi_tau^A = varphi_tau^v_1 circ varphi_tau^v_2 circ dotsc circ varphi_tau^v_r-1 circ varphi_tau^v_r \nvarphi_tau^B = varphi_tau^v_r circ varphi_tau^v_r-1 circ dotsc circ varphi_tau^v_2 circ varphi_tau^v_1\nendaligned\n\nIntegrator:\n\nvarphi_tau^NS = varphi_b_s tau^B circ varphi_a_s tau^A circ dotsc circ varphi_b_1 tau^B circ varphi_a_1 tau^A\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.TableauSplittingSS","page":"Integrators","title":"GeometricIntegrators.Integrators.TableauSplittingSS","text":"Tableau for symmetric splitting methods with symmetric stages.     See McLachlan, Quispel, 2003, Equ. (4.6).\n\nBasic method: symmetric Strang composition\n\nvarphi_tau^A = varphi_tau2^v_1 circ varphi_tau2^v_2 circ dotsc circ varphi_tau2^v_r-1 circ varphi_tau2^v_r circ varphi_tau2^v_r circ varphi_tau2^v_r-1 circ dotsc circ varphi_tau2^v_2 circ varphi_tau2^v_1\n\nIntegrator:\n\nvarphi_tau^SS = varphi_a_1 tau^A circ varphi_a_2 tau^A circ dotsc circ varphi_a_s tau^A circ dotsc circ varphi_a_2 tau^A circ varphi_a_1 tau^A\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#Runge-Kutta-Methods","page":"Integrators","title":"Runge-Kutta Methods","text":"","category":"section"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"Modules = [GeometricIntegrators.Integrators]\nPages   = [\"integrators/rk/bstract_integrator_rk.jl\",\n           \"integrators/rk/coefficients.jl\",\n           \"integrators/rk/tableaus.jl\",\n           \"integrators/rk/integrators_erk.jl\",\n           \"integrators/rk/integrators_dirk.jl\",\n           \"integrators/rk/integrators_firk.jl\",\n           \"integrators/rk/integrators_eprk.jl\",\n           \"integrators/rk/integrators_iprk.jl\",\n           \"integrators/rk/integrators_flrk.jl\",\n           \"integrators/rk/integrators_pglrk.jl\"]","category":"page"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.AbstractTableauPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.AbstractTableauPRK","text":"Holds the tableau of a partitioned Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.AbstractTableauRK","page":"Integrators","title":"GeometricIntegrators.Integrators.AbstractTableauRK","text":"Holds the tableau of a Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorCacheERK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorCacheERK","text":"Explicit Runge-Kutta integrator cache.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorERK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorERK","text":"Explicit Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.ParametersERK","page":"Integrators","title":"GeometricIntegrators.Integrators.ParametersERK","text":"Parameters for right-hand side function of explicit Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorCacheDIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorCacheDIRK","text":"Diagonally implicit Runge-Kutta integrator cache.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorDIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorDIRK","text":"Diagonally implicit Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.ParametersDIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.ParametersDIRK","text":"Parameters for right-hand side function of diagonally implicit Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.ParametersDIRK{DT,TT,D,S,ET} where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict,Int64}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of fully implicit Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.initial_guess!-Union{Tuple{DT}, Tuple{IntegratorDIRK{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessODE{TT,VT,IT} where IT<:Interpolator{TT} where VT) where ST where PT<:(GeometricIntegrators.Integrators.ParametersDIRK{DT,TT,D,S,ET} where ET<:NamedTuple where S where D) where S where D where TT,AtomicSolutionODE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N) where TT<:Real}, Tuple{IntegratorDIRK{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessODE{TT,VT,IT} where IT<:Interpolator{TT} where VT) where ST where PT<:(GeometricIntegrators.Integrators.ParametersDIRK{DT,TT,D,S,ET} where ET<:NamedTuple where S where D) where S where D where TT,AtomicSolutionODE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N) where TT<:Real,GeometricIntegrators.Integrators.IntegratorCacheDIRK{DT,D,S} where S where D}} where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.initial_guess!","text":"Compute initial guess for internal stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.initialize!-Tuple{IntegratorDIRK,GeometricIntegrators.Integrators.IntegratorCacheDIRK}","page":"Integrators","title":"GeometricIntegrators.Integrators.initialize!","text":"Initialise initial guess\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorCacheFIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorCacheFIRK","text":"Fully implicit Runge-Kutta integrator cache.\n\nFields\n\nq̃: initial guess of solution\nṽ: initial guess of vector field\ns̃: holds shift due to periodicity of solution\nQ: internal stages of solution\nV: internal stages of vector field\nY: vector field of internal stages\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorFIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorFIRK","text":"Fully implicit Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.ParametersFIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.ParametersFIRK","text":"Parameters for right-hand side function of fully implicit Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.ParametersFIRK{DT,TT,D,S,ET,FT,JT} where JT where FT where ET<:NamedTuple where S,GeometricIntegrators.Integrators.CacheDict}} where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of fully implicit Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.jacobian!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{Array{DT,1},Array{DT,2},GeometricIntegrators.Integrators.IntegratorCacheFIRK{DT,D,S},GeometricIntegrators.Integrators.ParametersFIRK{DT,TT,D,S,ET,FT,JT} where JT where FT where ET<:NamedTuple}} where S where D where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.jacobian!","text":"Compute stages of fully implicit Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorCacheEPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorCacheEPRK","text":"Explicit Runge-Kutta integrator cache.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorEPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorEPRK","text":"Explicit partitioned Runge-Kutta integrator solving the system\n\nbeginaligned\nV_ni = v (Q_ni P_ni)  \nQ_ni = q_n + h sum limits_j=1^s a_ij  V_nj  \nq_n+1 = q_n + h sum limits_i=1^s b_i  V_ni  \nF_ni = f (Q_ni P_ni)  \nP_ni = p_n + h  sum limits_i=1^s bara_ij  F_nj  \np_n+1 = p_n + h sum limits_i=1^s barb_i  F_ni \nendaligned\n\nUsually we are interested in Hamiltonian systems, where\n\nbeginaligned\nV_ni = dfracpartial Hpartial p (Q_ni P_ni)  \nF_ni = - dfracpartial Hpartial q (Q_ni P_ni)  \nendaligned\n\nand tableaus satisfying the symplecticity conditions\n\nbeginaligned\nb_i bara_ij + barb_j a_ji = b_i barb_j  \nbarb_i = b_i \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.ParametersEPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.ParametersEPRK","text":"Parameters for right-hand side function of explicit partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.computeStageP!-Union{Tuple{TT}, Tuple{DT}, Tuple{IntegratorEPRK{DT,TT,D,S,ET} where ET<:NamedTuple where S where D,GeometricIntegrators.Integrators.IntegratorCacheEPRK{DT,D,S} where S where D,Int64,Int64,TT}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.computeStageP!","text":"Compute P stages of explicit partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.computeStageQ!-Union{Tuple{TT}, Tuple{DT}, Tuple{IntegratorEPRK{DT,TT,D,S,ET} where ET<:NamedTuple where S where D,GeometricIntegrators.Integrators.IntegratorCacheEPRK{DT,D,S} where S where D,Int64,Int64,TT}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.computeStageQ!","text":"Compute Q stages of explicit partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorCacheIPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorCacheIPRK","text":"Implicit partitioned Runge-Kutta integrator cache.\n\nFields\n\nq̃: initial guess of q\np̃: initial guess of p\nṽ: initial guess of v\nf̃: initial guess of f\ns̃: holds shift due to periodicity of solution\nQ: internal stages of q\nP: internal stages of p\nV: internal stages of v\nF: internal stages of f\nY: vector field of internal stages of q\nZ: vector field of internal stages of p\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorIPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorIPRK","text":"Implicit partitioned Runge-Kutta integrator solving the system\n\nbeginaligned\nV_ni = v (Q_ni P_ni)  \nQ_ni = q_n + h sum limits_j=1^s a_ij  V_nj  \nq_n+1 = q_n + h sum limits_i=1^s b_i  V_ni  \nF_ni = f (Q_ni P_ni)  \nP_ni = p_n + h  sum limits_i=1^s bara_ij  F_nj  \np_n+1 = p_n + h sum limits_i=1^s barb_i  F_ni \nendaligned\n\nUsually we are interested in Hamiltonian systems, where\n\nbeginaligned\nV_ni = dfracpartial Hpartial p (Q_ni P_ni)  \nF_ni = - dfracpartial Hpartial q (Q_ni P_ni)  \nendaligned\n\nand tableaus satisfying the symplecticity conditions\n\nbeginaligned\nb_i bara_ij + barb_j a_ji = b_i barb_j  \nbarb_i = b_i \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.ParametersIPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.ParametersIPRK","text":"Parameters for right-hand side function of implicit partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.ParametersIPRK{DT,TT,D,S,ET} where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of implicit partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorFLRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorFLRK","text":"Formal Lagrangian Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.ParametersFLRK","page":"Integrators","title":"GeometricIntegrators.Integrators.ParametersFLRK","text":"Parameters for right-hand side function of formal Lagrangian Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.ParametersFLRK{DT,TT,D,S,ET} where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of formal Lagrangian Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.CoefficientsPGLRK","page":"Integrators","title":"GeometricIntegrators.Integrators.CoefficientsPGLRK","text":"Holds the coefficients of a projected Gauss-Legendre Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorPGLRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorPGLRK","text":"Projected Gauss-Legendre Runge-Kutta integrator.\n\nReference: LUIGI BRUGNANO, FELICE IAVERNARO, AND DONATO TRIGIANTE.\n    ENERGY- AND QUADRATIC INVARIANTS–PRESERVING INTEGRATORS BASED\n    UPON GAUSS COLLOCATION FORMULAE.\n    SIAM J. NUMER. ANAL. Vol. 50, No. 6, pp. 2897–2916, 2012.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.ParametersPGLRK","page":"Integrators","title":"GeometricIntegrators.Integrators.ParametersPGLRK","text":"Parameters for right-hand side function of projected Gauss-Legendre Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#Base.show-Tuple{IO,CoefficientsPGLRK}","page":"Integrators","title":"Base.show","text":"Print Runge-Kutta coefficients.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.ParametersPGLRK{DT,TT,D,S,ET} where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of projected Gauss-Legendre Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#SPARK-Methods","page":"Integrators","title":"SPARK Methods","text":"","category":"section"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"Modules = [GeometricIntegrators.Integrators.SPARK]","category":"page"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.AbstractParametersSPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.AbstractParametersSPARK","text":"Parameters for right-hand side function of Specialised Partitioned Additive Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.AbstractTableauSPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.AbstractTableauSPARK","text":"Holds the tableau of an Specialised Partitioned Additive Runge-Kutta method for Variational systems.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.CoefficientsARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.CoefficientsARK","text":"Holds the coefficients of an additive Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.CoefficientsIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.CoefficientsIRK","text":"Holds the coefficients of an additive Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.CoefficientsMRK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.CoefficientsMRK","text":"Holds the multiplier Runge-Kutta coefficients.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.CoefficientsPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.CoefficientsPRK","text":"Holds the coefficients of a projective Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.CoefficientsSPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.CoefficientsSPARK","text":"Holds the coefficients of a SPARK method.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.IntegratorCacheSPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.IntegratorCacheSPARK","text":"Cache of a Specialised Partitioned Additive Runge-Kutta integrator.\n\nFields\n\nn: time step number\nt: time of current time step\nt̅: time of previous time step\nq: current solution of q\nq̅: previous solution of q\np: current solution of p\np̅: previous solution of p\nv: vector field of q\nv̅: vector field of q̅\nf: vector field of p\nf̅: vector field of p̅\nq̃: initial guess of q\np̃: initial guess of p\nṽ: initial guess of v\nf̃: initial guess of f\ns̃: holds shift due to periodicity of solution\nQ: internal stages of q\nP: internal stages of p\nV: internal stages of v\nF: internal stages of f\nY: vector field of internal stages of q\nZ: vector field of internal stages of p\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.IntegratorHPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.IntegratorHPARK","text":"Partitioned Additive Runge-Kutta integrator for Hamiltonian systems subject to Dirac constraints EXPERIMENTAL.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij V_nj + h sum limits_j=1^r alpha_ij U_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s a_ij F_nj + h sum limits_j=1^r alpha_ij G_nj   i = 1  s  \ntildeQ_ni = q_n + h sum limits_j=1^s tildea_ij V_nj + h sum limits_j=1^r tildealpha_ij U_nj   i = 1  r  \ntildeP_ni = p_n + h sum limits_j=1^s tildea_ij F_nj + h sum limits_j=1^r tildealpha_ij G_nj   i = 1  r  \ntildePhi_ni = 0   i = 1  r \nendaligned\n\nwith definitions\n\nbeginaligned\nV_ni = hphantom- fracpartial Hpartial p (Q_ni P_ni)   i = 1  s  \nF_ni =           -  fracpartial Hpartial q (Q_ni P_ni)   i = 1  s  \nU_ni = hphantom- fracpartial phipartial p (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \nG_ni =           -  fracpartial phipartial q (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \ntildePhi_ni = phi(tildeQ_ni tildeP_ni)   i = 1  r \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i V_ni + h sum limits_i=1^r beta_i U_ni  \np_n+1 = p_n + h sum limits_i=1^s b_i F_ni + h sum limits_i=1^r beta_i G_ni \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.IntegratorHSPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.IntegratorHSPARK","text":"Specialised Partitioned Additive Runge-Kutta integrator for Hamiltonian systems EXPERIMENTAL.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij V_nj + h sum limits_j=1^r alpha_ij U_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s a_ij F_nj + h sum limits_j=1^r alpha_ij G_nj   i = 1  s  \ntildeQ_ni = q_n + h sum limits_j=1^s tildea_ij V_nj + h sum limits_j=1^r tildealpha_ij U_nj   i = 1  r  \ntildeP_ni = p_n + h sum limits_j=1^s tildea_ij F_nj + h sum limits_j=1^r tildealpha_ij G_nj   i = 1  r  \n0 = sum limits_j=1^r omega_ij tildePhi_nj   i = 1  r-1 \nendaligned\n\nwith definitions\n\nbeginaligned\nV_ni = hphantom- fracpartial Hpartial p (Q_ni P_ni)   i = 1  s  \nF_ni =           -  fracpartial Hpartial q (Q_ni P_ni)   i = 1  s  \nU_ni = hphantom- fracpartial phipartial p (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \nG_ni =           -  fracpartial phipartial q (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \ntildePhi_ni = phi(tildeQ_ni tildeP_ni)   i = 1  r \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i V_ni + h sum limits_i=1^r beta_i U_ni  \np_n+1 = p_n + h sum limits_i=1^s b_i F_ni + h sum limits_i=1^r beta_i G_ni  \n0 = phi (q_n+1 p_n+1) \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.IntegratorHSPARKprimary","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.IntegratorHSPARKprimary","text":"Specialised Partitioned Additive Runge-Kutta integrator for Hamiltonian systems EXPERIMENTAL.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij V_nj + h sum limits_j=1^r alpha_ij U_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s a_ij F_nj + h sum limits_j=1^r alpha_ij G_nj   i = 1  s  \ntildeQ_ni = q_n + h sum limits_j=1^s tildea_ij V_nj + h sum limits_j=1^r tildealpha_ij U_nj   i = 1  r  \ntildeP_ni = p_n + h sum limits_j=1^s tildea_ij F_nj + h sum limits_j=1^r tildealpha_ij G_nj   i = 1  r  \n0 = sum limits_j=1^r omega_ij tildePhi_nj   i = 1  r-1 \nendaligned\n\nwith definitions\n\nbeginaligned\nV_ni = hphantom- fracpartial Hpartial p (Q_ni P_ni)   i = 1  s  \nF_ni =           -  fracpartial Hpartial q (Q_ni P_ni)   i = 1  s  \nU_ni = hphantom- fracpartial phipartial p (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \nG_ni =           -  fracpartial phipartial q (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \ntildePhi_ni = phi(tildeQ_ni tildeP_ni)   i = 1  r \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i V_ni + h sum limits_i=1^r beta_i U_ni  \np_n+1 = p_n + h sum limits_i=1^s b_i F_ni + h sum limits_i=1^r beta_i G_ni  \n0 = phi (q_n+1 p_n+1) \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.IntegratorHSPARKsecondary","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.IntegratorHSPARKsecondary","text":"Specialised Partitioned Additive Runge-Kutta integrator for Hamiltonian systems subject to Dirac constraints with projection on secondary constraint EXPERIMENTAL.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij V_nj + h sum limits_j=1^r alpha_ij U_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s a_ij F_nj + h sum limits_j=1^r alpha_ij G_nj   i = 1  s  \ntildeQ_ni = q_n + h sum limits_j=1^s tildea_ij V_nj + h sum limits_j=1^r tildealpha_ij U_nj   i = 1  r  \ntildeP_ni = p_n + h sum limits_j=1^s tildea_ij F_nj + h sum limits_j=1^r tildealpha_ij G_nj   i = 1  r  \n0 = sum limits_j=1^r omega_ij tildePhi_nj   i = 1  r-1 \nendaligned\n\nwith definitions\n\nbeginaligned\nV_ni = hphantom- fracpartial Hpartial p (Q_ni P_ni)   i = 1  s  \nF_ni =           -  fracpartial Hpartial q (Q_ni P_ni)   i = 1  s  \nU_ni = hphantom- fracpartial phipartial p (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \nG_ni =           -  fracpartial phipartial q (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \ntildePhi_ni = phi(tildeQ_ni tildeP_ni)   i = 1  r \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i V_ni + h sum limits_i=1^r beta_i U_ni  \np_n+1 = p_n + h sum limits_i=1^s b_i F_ni + h sum limits_i=1^r beta_i G_ni  \n0 = phi (q_n+1 p_n+1) \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.IntegratorSLRK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.IntegratorSLRK","text":"Specialised Partitioned Additive Runge-Kutta integrator for degenerate variational systems with projection on secondary constraint.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a^1_ij V_nj + h sum limits_j=1^sigma a^2_ij tildeLambda_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s bara^1_ij F^1_nj + h sum limits_j=1^s bara^2_ij F^2_nj + h sum limits_j=1^sigma bara^3_ij tildeF^3_nj   i = 1  s  \n0 = Phi_ni   i = 1  s \nendaligned\n\nthe projective stages\n\nbeginaligned\ntildeQ_ni = q_n + h sum limits_j=1^s alpha^1_ij tildeV_nj + h sum limits_j=1^sigma alpha^2_ij tildeLambda_nj   i = 1  sigma  \ntildeP_ni = p_n + h sum limits_j=1^s baralpha^1_ij F^1_nj + h sum limits_j=1^s baralpha^2_ij tildeF^2_nj + h sum limits_j=1^sigma baralpha^3_ij tildeF^3_nj   i = 1  sigma  \n0 = tildePhi_ni   i = 1  sigma  \n0 = sum limits_j=1^sigma omega_ij tildePsi_ni   i = 1  sigma-1 \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b^1_i V_ni + h sum limits_i=1^sigma b^2_i tildeLambda_ni  \np_n+1 = p_n + h sum limits_i=1^s b^1_i F^1_ni + h sum limits_i=1^s b^2_i F^2_ni + h sum limits_i=1^sigma b^3_i tildeF^3_ni  \n0 = phi (q_n+1 p_n+1) \nendaligned\n\nwith definitions\n\nbeginaligned\nF^1_ni = nabla H (Q_ni)   i = 1  s  \nF^2_ni = nabla vartheta (Q_ni) cdot V_ni   i = 1  s  \ntildeF^3_ni = nabla phi (tildeQ_ni tildeP_ni) cdot tildeLambda_ni   i = 1  sigma  \nPhi_ni = phi (Q_ni P_ni) = P_ni - vartheta (Q_ni)   i = 1  s  \ntildePhi_ni = phi (tildeQ_ni tildeP_ni) = tildeP_ni - vartheta (tildeQ_ni)   i = 1  sigma  \ntildePsi_ni = psi (tildeQ_ni tildeV_ni tildeP_ni tildeF_ni) = tildeF_ni - tildeV_ni cdot nabla vartheta (tildeQ_ni)   i = 1  sigma \nendaligned\n\nso that\n\nbeginaligned\nF^1_ni + F^2_ni = fracpartial Lpartial q (Q_ni V_ni)   i = 1  s  \nphi (Q_ni P_ni) = P_ni - fracpartial Lpartial v (Q_ni V_ni)   i = 1  s  \npsi (tildeQ_ni tildeV_ni tildeP_ni tildeF_ni) = tildeF_ni - tildeV_ni cdot nabla fracpartial Lpartial v (tildeQ_ni tildeV_ni)   i = 1  sigma \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.IntegratorSPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.IntegratorSPARK","text":"Specialised Partitioned Additive Runge-Kutta integrator for index-two DAE systems.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij V_nj + h sum limits_j=1^r alpha_ij U_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s a_ij F_nj + h sum limits_j=1^r alpha_ij G_nj   i = 1  s  \ntildeQ_ni = q_n + h sum limits_j=1^s tildea_ij V_nj + h sum limits_j=1^r tildealpha_ij U_nj   i = 1  r  \ntildeP_ni = p_n + h sum limits_j=1^s tildea_ij F_nj + h sum limits_j=1^r tildealpha_ij G_nj   i = 1  r  \n0 = sum limits_j=1^r omega_ij tildePhi_nj   i = 1  r-1 \nendaligned\n\nwith definitions\n\nbeginaligned\nP_ni = fracpartial Lpartial v (Q_ni V_ni)   i = 1  s  \nF_ni = fracpartial Lpartial q (Q_ni V_ni)   i = 1  s  \nU_ni = hphantom- fracpartial phipartial p (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \nG_ni =           -  fracpartial phipartial q (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \ntildePhi_ni = phi(tildeQ_ni tildeP_ni)   i = 1  r \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i V_ni + h sum limits_i=1^r beta_i U_ni  \np_n+1 = p_n + h sum limits_i=1^s b_i F_ni + h sum limits_i=1^r beta_i G_ni  \n0 = phi (q_n+1 p_n+1) \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.IntegratorVPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.IntegratorVPARK","text":"Variational partitioned additive Runge-Kutta integrator.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij V_nj + h sum limits_j=1^r alpha_ij U_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s a_ij F_nj + h sum limits_j=1^r alpha_ij G_nj   i = 1  s  \ntildeQ_ni = q_n + h sum limits_j=1^s tildea_ij V_nj + h sum limits_j=1^r tildealpha_ij U_nj   i = 1  r  \ntildeP_ni = p_n + h sum limits_j=1^s tildea_ij F_nj + h sum limits_j=1^r tildealpha_ij G_nj   i = 1  r  \ntildePhi_ni = 0   i = 1  r \nendaligned\n\nwith definitions\n\nbeginaligned\nP_ni = fracpartial Lpartial v (Q_ni V_ni)   i = 1  s  \nF_ni = fracpartial Lpartial q (Q_ni V_ni)   i = 1  s  \nU_ni = hphantom- fracpartial phipartial p (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \nG_ni =           -  fracpartial phipartial q (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \ntildePhi_ni = phi(tildeQ_ni tildeP_ni)   i = 1  r \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i V_ni + h sum limits_i=1^r beta_i U_ni  \np_n+1 = p_n + h sum limits_i=1^s b_i F_ni + h sum limits_i=1^r beta_i G_ni \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.IntegratorVSPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.IntegratorVSPARK","text":"Specialised Partitioned Additive Runge-Kutta integrator for Variational systems.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij V_nj + h sum limits_j=1^r alpha_ij U_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s a_ij F_nj + h sum limits_j=1^r alpha_ij G_nj   i = 1  s  \ntildeQ_ni = q_n + h sum limits_j=1^s tildea_ij V_nj + h sum limits_j=1^r tildealpha_ij U_nj   i = 1  r  \ntildeP_ni = p_n + h sum limits_j=1^s tildea_ij F_nj + h sum limits_j=1^r tildealpha_ij G_nj   i = 1  r  \n0 = sum limits_j=1^r omega_ij tildePhi_nj   i = 1  r-1 \nendaligned\n\nwith definitions\n\nbeginaligned\nP_ni = fracpartial Lpartial v (Q_ni V_ni)   i = 1  s  \nF_ni = fracpartial Lpartial q (Q_ni V_ni)   i = 1  s  \nU_ni = hphantom- fracpartial phipartial p (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \nG_ni =           -  fracpartial phipartial q (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \ntildePhi_ni = phi(tildeQ_ni tildeP_ni)   i = 1  r \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i V_ni + h sum limits_i=1^r beta_i U_ni  \np_n+1 = p_n + h sum limits_i=1^s b_i F_ni + h sum limits_i=1^r beta_i G_ni  \n0 = phi (q_n+1 p_n+1) \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.IntegratorVSPARKprimary","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.IntegratorVSPARKprimary","text":"Specialised Partitioned Additive Runge-Kutta integrator for Variational systems.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij V_nj + h sum limits_j=1^r alpha_ij U_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s a_ij F_nj + h sum limits_j=1^r alpha_ij G_nj   i = 1  s  \ntildeQ_ni = q_n + h sum limits_j=1^s tildea_ij V_nj + h sum limits_j=1^r tildealpha_ij U_nj   i = 1  r  \ntildeP_ni = p_n + h sum limits_j=1^s tildea_ij F_nj + h sum limits_j=1^r tildealpha_ij G_nj   i = 1  r  \n0 = sum limits_j=1^r omega_ij tildePhi_nj   i = 1  r-1  \n0 = sum limits_i=1^r tilded_i  Lambda_ni \nendaligned\n\nwith definitions\n\nbeginaligned\nP_ni = fracpartial Lpartial v (Q_ni V_ni)   i = 1  s  \nF_ni = fracpartial Lpartial q (Q_ni V_ni)   i = 1  s  \nU_ni = hphantom- fracpartial phipartial p (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \nG_ni =           -  fracpartial phipartial q (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \ntildePhi_ni = phi(tildeQ_ni tildeP_ni)   i = 1  r \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i V_ni + h sum limits_i=1^r beta_i U_ni  \np_n+1 = p_n + h sum limits_i=1^s b_i F_ni + h sum limits_i=1^r beta_i G_ni \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.IntegratorVSPARKsecondary","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.IntegratorVSPARKsecondary","text":"Specialised Partitioned Additive Runge-Kutta integrator for degenerate variational systems with projection on secondary constraint.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a^1_ij V_nj + h sum limits_j=1^sigma a^2_ij tildeLambda_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s bara^1_ij F^1_nj + h sum limits_j=1^s bara^2_ij F^2_nj + h sum limits_j=1^sigma bara^3_ij tildeF^3_nj   i = 1  s  \n0 = Phi_ni   i = 1  s \nendaligned\n\nthe projective stages\n\nbeginaligned\ntildeQ_ni = q_n + h sum limits_j=1^s alpha^1_ij tildeV_nj + h sum limits_j=1^sigma alpha^2_ij tildeLambda_nj   i = 1  sigma  \ntildeP_ni = p_n + h sum limits_j=1^s baralpha^1_ij F^1_nj + h sum limits_j=1^s baralpha^2_ij tildeF^2_nj + h sum limits_j=1^sigma baralpha^3_ij tildeF^3_nj   i = 1  sigma  \n0 = tildePhi_ni   i = 1  sigma  \n0 = sum limits_j=1^sigma omega_ij tildePsi_ni   i = 1  sigma-1 \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b^1_i V_ni + h sum limits_i=1^sigma b^2_i tildeLambda_ni  \np_n+1 = p_n + h sum limits_i=1^s b^1_i F^1_ni + h sum limits_i=1^s b^2_i F^2_ni + h sum limits_i=1^sigma b^3_i tildeF^3_ni  \n0 = phi (q_n+1 p_n+1) \nendaligned\n\nwith definitions\n\nbeginaligned\nF^1_ni = nabla H (Q_ni)   i = 1  s  \nF^2_ni = nabla vartheta (Q_ni) cdot V_ni   i = 1  s  \ntildeF^3_ni = nabla phi (tildeQ_ni tildeP_ni) cdot tildeLambda_ni   i = 1  sigma  \nPhi_ni = phi (Q_ni P_ni) = P_ni - vartheta (Q_ni)   i = 1  s  \ntildePhi_ni = phi (tildeQ_ni tildeP_ni) = tildeP_ni - vartheta (tildeQ_ni)   i = 1  sigma  \ntildePsi_ni = psi (tildeQ_ni tildeV_ni tildeP_ni tildeF_ni) = tildeF_ni - tildeV_ni cdot nabla vartheta (tildeQ_ni)   i = 1  sigma \nendaligned\n\nso that\n\nbeginaligned\nF^1_ni + F^2_ni = fracpartial Lpartial q (Q_ni V_ni)   i = 1  s  \nphi (Q_ni P_ni) = P_ni - fracpartial Lpartial v (Q_ni V_ni)   i = 1  s  \npsi (tildeQ_ni tildeV_ni tildeP_ni tildeF_ni) = tildeF_ni - tildeV_ni cdot nabla fracpartial Lpartial v (tildeQ_ni tildeV_ni)   i = 1  sigma \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.ParametersHPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.ParametersHPARK","text":"Parameters for right-hand side function of Hamiltonian Partitioned Additive Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.ParametersSLRK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.ParametersSLRK","text":"Parameters for right-hand side function of Specialised Partitioned Additive Runge-Kutta methods for Variational systems.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.ParametersVPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.ParametersVPARK","text":"Parameters for right-hand side function of Variational Partitioned Additive Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.ParametersVSPARKsecondary","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.ParametersVSPARKsecondary","text":"Parameters for right-hand side function of Specialised Partitioned Additive Runge-Kutta methods for Variational systems.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.TableauHPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.TableauHPARK","text":"Holds the tableau of a Hamiltonian Partitioned Additive Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.TableauSLRK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.TableauSLRK","text":"Holds the tableau of an Specialised Partitioned Additive Runge-Kutta method for Variational systems.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.TableauSPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.TableauSPARK","text":"Holds the tableau of an Specialised Partitioned Additive Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.TableauVPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.TableauVPARK","text":"Holds the tableau of an Variational Partitioned Additive Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.TableauVSPARKsecondary","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.TableauVSPARKsecondary","text":"Holds the tableau of an Specialised Partitioned Additive Runge-Kutta method for Variational systems.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#Base.show-Tuple{IO,GeometricIntegrators.Integrators.SPARK.CoefficientsARK}","page":"Integrators","title":"Base.show","text":"Print additive Runge-Kutta coefficients.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#Base.show-Tuple{IO,GeometricIntegrators.Integrators.SPARK.CoefficientsIRK}","page":"Integrators","title":"Base.show","text":"Print additive Runge-Kutta coefficients.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#Base.show-Tuple{IO,GeometricIntegrators.Integrators.SPARK.CoefficientsMRK}","page":"Integrators","title":"Base.show","text":"Print multiplier Runge-Kutta coefficients.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#Base.show-Tuple{IO,GeometricIntegrators.Integrators.SPARK.CoefficientsPRK}","page":"Integrators","title":"Base.show","text":"Print projective Runge-Kutta coefficients.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#Base.show-Tuple{IO,GeometricIntegrators.Integrators.SPARK.CoefficientsSPARK}","page":"Integrators","title":"Base.show","text":"Print SPARK coefficients.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{P}, Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.SPARK.AbstractParametersSPARK{:hspark,DT,TT,D,S,R,P,equType,tabType} where tabType<:AbstractTableau where equType<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where P where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of specialised partitioned additive Runge-Kutta methods for variational systems.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{P}, Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.SPARK.AbstractParametersSPARK{:hspark_primary,DT,TT,D,S,R,P,equType,tabType} where tabType<:AbstractTableau where equType<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where P where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of specialised partitioned additive Runge-Kutta methods for variational systems.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{P}, Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.SPARK.AbstractParametersSPARK{:spark,DT,TT,D,S,R,P,equType,tabType} where tabType<:AbstractTableau where equType<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where P where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of specialised partitioned additive Runge-Kutta methods for variational systems.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{P}, Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.SPARK.AbstractParametersSPARK{:vspark,DT,TT,D,S,R,P,equType,tabType} where tabType<:AbstractTableau where equType<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where P where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of specialised partitioned additive Runge-Kutta methods for variational systems.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{P}, Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.SPARK.AbstractParametersSPARK{:vspark_primary,DT,TT,D,S,R,P,equType,tabType} where tabType<:AbstractTableau where equType<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where P where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of specialised partitioned additive Runge-Kutta methods for variational systems.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.SPARK.AbstractParametersSPARK{:hpark,DT,TT,D,S,R,P,equType,tabType} where tabType<:AbstractTableau where equType<:NamedTuple where P,GeometricIntegrators.Integrators.CacheDict}} where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of variational partitioned additive Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.SPARK.AbstractParametersSPARK{:hspark_secondary,DT,TT,D,S,R,P,equType,tabType} where tabType<:AbstractTableau where equType<:NamedTuple where P,GeometricIntegrators.Integrators.CacheDict}} where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of specialised partitioned additive Runge-Kutta methods for variational systems.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.SPARK.AbstractParametersSPARK{:vpark,DT,TT,D,S,R,P,equType,tabType} where tabType<:AbstractTableau where equType<:NamedTuple where P,GeometricIntegrators.Integrators.CacheDict}} where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of variational partitioned additive Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.SPARK.AbstractParametersSPARK{:vspark_secondary,DT,TT,D,S,R,P,equType,tabType} where tabType<:AbstractTableau where equType<:NamedTuple where P,GeometricIntegrators.Integrators.CacheDict}} where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of specialised partitioned additive Runge-Kutta methods for variational systems.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.SPARK.AbstractParametersSPARK{:slrk,DT,TT,D,S,R,P,equType,tabType} where tabType<:AbstractTableau where equType<:NamedTuple where P where R,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of specialised partitioned additive Runge-Kutta methods for variational systems.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#VPRK-Methods","page":"Integrators","title":"VPRK Methods","text":"","category":"section"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"Modules = [GeometricIntegrators.Integrators.VPRK]","category":"page"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK","text":"Parameters for right-hand side function of variational partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorCacheVPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorCacheVPRK","text":"Variational partitioned Runge-Kutta integrator cache.\n\nFields\n\nq̃: initial guess of q\np̃: initial guess of p\nṽ: initial guess of v\nf̃: initial guess of f\ns̃: holds shift due to periodicity of solution\nQ: internal stages of q\nP: internal stages of p\nV: internal stages of v\nF: internal stages of f\nY: integral of vector field of internal stages of q\nZ: integral of vector field of internal stages of p\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRK","text":"Variational partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKdegenerate","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRKdegenerate","text":"Variational partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpInternal","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpInternal","text":"Variational partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpLegendre","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpLegendre","text":"Variational special partitioned additive Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpMidpoint","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpMidpoint","text":"Variational partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpSecondary","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpSecondary","text":"Variational partitioned Runge-Kutta integrator with projection on secondary constraint.\n\nThe VPRK integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij  big( V_nj + Lambda_nj big)  \nP_ni = p_n + h sum limits_i=1^s bara_ij  big( F_nj + nabla vartheta (Q_nj)^T cdot Lambda_nj big) - d_i lambda  \n0 = sum limits_i=1^s d_i V_i  \n0 = sum limits_j=1^s omega_ij Psi_nj \nendaligned\n\nwith definitions\n\nbeginaligned\nP_ni = dfracpartial Lpartial v (Q_ni V_ni)  \nF_ni = dfracpartial Lpartial q (Q_ni V_ni)  \nPsi_ni = psi(Q_ni V_ni P_ni F_ni) \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i  big( V_ni + Lambda_ni big)  \np_n+1 = p_n + h sum limits_i=1^s barb_i  big( F_ni + nabla vartheta (Q_nj)^T cdot Lambda_nj big)  \n0 = phi (q_n+1 p_n+1) \nendaligned\n\nsatisfying the symplecticity conditions\n\nbeginaligned\nb_i bara_ij + barb_j a_ji = b_i barb_j  \nbarb_i = b_i \nendaligned\n\nthe primary constraint,\n\nbeginaligned\nphi(qp) = p - vartheta (q) = 0 \nendaligned\n\nat the final solution (q_n+1 p_n+1), and super positions of the secondary constraints,\n\nbeginaligned\npsi(qdotqpdotp)\n= dotp - dotq cdot nabla vartheta (q)\n= big( nabla vartheta (q) - nabla vartheta^T (q) big) cdot dotq - nabla H (q)\n= 0\nendaligned\n\nwhich, evaluated at the internal stages, read\n\nbeginaligned\nPsi_nj = big( nabla vartheta (Q_nj) - nabla vartheta^T (Q_nj) big) cdot V_nj - nabla H (Q_nj) \nendaligned\n\nHere, omega is a (s-1) times s matrix, chosen such that the resulting method has optimal order. The vector d is zero for Gauss-Legendre methods and needs to be chosen appropriately for Gauss-Lobatto methods (for details see documentation of VPRK methods).\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpStandard","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpStandard","text":"Variational partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpStandard-Tuple","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpStandard","text":"Variational partitioned Runge-Kutta integrator with standard projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpSymmetric","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpSymmetric","text":"Variational partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpTableau","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpTableau","text":"Projected Variational Gauss-Legendre Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpVariational","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpVariational","text":"Variational partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.ParametersVPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.ParametersVPRK","text":"Parameters for right-hand side function of Variational Partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.ParametersVPRKdegenerate","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.ParametersVPRKdegenerate","text":"Parameters for right-hand side function of Variational Partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.ParametersVPRKpInternal","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.ParametersVPRKpInternal","text":"Parameters for right-hand side function of Variational Partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.ParametersVPRKpLegendre","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.ParametersVPRKpLegendre","text":"Parameters for right-hand side function of Variational Partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.ParametersVPRKpMidpoint","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.ParametersVPRKpMidpoint","text":"Parameters for right-hand side function of Variational Partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.ParametersVPRKpSecondary","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.ParametersVPRKpSecondary","text":"Parameters for right-hand side function of Variational Partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.ParametersVPRKpStandard","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.ParametersVPRKpStandard","text":"Parameters for right-hand side function of Variational Partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.ParametersVPRKpSymmetric","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.ParametersVPRKpSymmetric","text":"Parameters for right-hand side function of Variational Partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.ParametersVPRKpTableau","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.ParametersVPRKpTableau","text":"Parameters for right-hand side function of projected Gauss-Legendre Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.ParametersVPRKpVariational","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.ParametersVPRKpVariational","text":"Parameters for right-hand side function of Variational Partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.TableauVPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.TableauVPRK","text":"TableauVPRK: Tableau of a Variational Partitioned Runge-Kutta method\n\nbeginaligned\nP_ni = dfracpartial Lpartial v (Q_ni V_ni)  \nQ_ni = q_n + h sum limits_j=1^s a_ij  V_nj  \nq_n+1 = q_n + h sum limits_i=1^s b_i  V_ni  \nF_ni = dfracpartial Lpartial q (Q_ni V_ni)  \nP_ni = p_n + h sum limits_i=1^s bara_ij  F_nj - d_i lambda  \np_n+1 = p_n + h sum limits_i=1^s barb_i  F_ni  \n\n0 = sum limits_i=1^s d_i V_i  \nendaligned\n\nsatisfying the symplecticity conditions\n\nbeginaligned\nb_i bara_ij + b_j a_ji = b_i b_j  \nbarb_i = b_i \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpSymplectic-Tuple","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpSymplectic","text":"Variational partitioned Runge-Kutta integrator with symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpVariationalP-Tuple","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpVariationalP","text":"Variational partitioned Runge-Kutta integrator with variational projection on (p_n q_n+1).\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpVariationalQ-Tuple","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpVariationalQ","text":"Variational partitioned Runge-Kutta integrator with variational projection on (q_n p_n+1).\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of variational partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_degenerate,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute solution of degenerate symplectic partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_pinternal,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of variational partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_plegendre,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of variational special partitioned additive Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_pmidpoint,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of variational partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_psecondary,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of variational partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_pstandard,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of projected variational partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_psymmetric,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of variational partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_pvariational,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of projected variational partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.VPRK.ParametersVPRKpTableau{DT,TT,D,S,ET} where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of projected Gauss-Legendre Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#Galerkin-Variational-Integrators","page":"Integrators","title":"Galerkin Variational Integrators","text":"","category":"section"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"Modules = [GeometricIntegrators.Integrators]\nPages   = [\"integrators/cgvi/integrators_cgvi.jl\",\n           \"integrators/dgvi/integrators_dgvi.jl\"]","category":"page"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorCGVI","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorCGVI","text":"Continuous Galerkin Variational Integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.ParametersCGVI","page":"Integrators","title":"GeometricIntegrators.Integrators.ParametersCGVI","text":"ParametersCGVI: Parameters for right-hand side function of continuous Galerkin variational Integrator.\n\nParameters\n\nΘ: function of the noncanonical one-form (∂L/∂v)\nf: function of the force (∂L/∂q)\nΔt: time step\nb: weights of the quadrature rule\nc: nodes of the quadrature rule\nx: nodes of the basis\nm: mass matrix\na: derivative matrix\nr₀: reconstruction coefficients at the beginning of the interval\nr₁: reconstruction coefficients at the end of the interval\nt: initial time\nq: solution of q at time t\np: solution of p at time t\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.ParametersCGVI{DT,TT,D,S,R,ET} where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of variational partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorCacheDGVI","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorCacheDGVI","text":"Nonlinear function cache for Discontinuous Galerkin Variational Integrator.\n\nParameters\n\nST: data type\nD: number of dimensions\nS: number of degrees of freedom\nR: number of nodes of quadrature formula\n\nFields\n\nX: degrees of freedom\nQ: solution at quadrature nodes\nV: velocity at quadrature nodes\nP: one-form at quadrature nodes\nF: forces at quadrature nodes\nq:  current solution of q_n\nq⁻: current solution of q_n^-\nq⁺: current solution of q_n^+\nq̅:  current solution of q_n+1\nq̅⁻: current solution of q_n+1^-\nq̅⁺: current solution of q_n+1^+\nϕ:  average of the solution at t_n\nϕ̅:  average of the solution at t_n+1\nλ:  jump of the solution at t_n\nλ̅:  jump of the solution at t_n+1\nθ:  one-form evaluated across at t_n\nΘ̅:  one-form evaluated across at t_n+1\ng:  projection evaluated across at t_n\ng̅:  projection evaluated across at t_n+1\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorDGVI","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorDGVI","text":"IntegratorDGVI: Discontinuous Galerkin Variational Integrator.\n\nThe DGVI integrators arise from the discretization of the action integral\n\nmathcalA q = int limits_0^T L(q(t) dotq(t))  dt \n\nwith L a fully degenerate Lagrangian of the form\n\nL(q dotq) = vartheta (q) cdot dotq - H(q) \n\nwhere vartheta (q) denotes the Cartan one-form and H(q) the Hamiltonian, which is usually given by the total energy of the system.\n\nDiscretization\n\nWithin each interval (t_n t_n+1) a piecewise-polynomial approximation q_h of the trajectory q is constructed using S basis functions varphi_i,\n\nq_h(t) vert_(t_n t_n+1) = sum limits_i=1^S x_ni  barvarphi_ni (t) \n\nwhere barvarphi_ni (t) is a rescaled basis function, defined by\n\nbarvarphi_ni (t) = varphi_i bigg( fract - t_nt_n+1 - t_n bigg) \n\nand it is assumed that varphi_i is compactly supported on 01. These approximations q_h(t) are not assumed to be continuous across interval boundaries t_n but usuaslly have jumps.\n\nThe integral over (t_n t_n+1) is approximated by a quadrature rule with R nodes c_i and weights b_i. Denote by m and a mass and derivative matrices, respectively, whose elements  are given by\n\nm_ij = varphi_j (c_i) \nqquad\na_ij = varphi_j (c_i) \nqquad\ni = 1  R \n\nj = 1  S \n\nWith that, the solution and its time derivative at the quadrature points can be written as\n\nQ_ni equiv q_h(t_n + c_i h) = m_ij x_nj \nqquad\nV_ni equiv dotq_h (t_n + c_i h) = a_ij x_nj \n\nwhere\n\nx_n = ( x_n1  x_nS )^T\n\nis the vector containing the degrees of freedom of q_h vert_t_n t_n+1. The limits of q_h(t) at t_n and t_n+1 are given by\n\nq_n^+ = lim limits_t downarrow t_n q_h(t) = sum limits_j=1^S r^+_j delta x_nj \nhspace3em\nq_n+1^- = lim limits_t uparrow t_n+1 q_h(t) = sum limits_j=1^S r^-_j delta x_nj \n\nThe discrete action reads\n\nmathcalA_d x_d = h sum limits_n=0^N-1 bigg\n     sum limits_i=1^R b_i big vartheta (Q_ni) cdot V_ni - H(Q_ni) big \n     + fracvartheta (q_n) + vartheta (q_n^+)2 cdot (q_n^+ - q_n)\n     + fracvartheta (q_n+1^-) + vartheta (q_n+1)2 cdot (q_n+1 - q_n+1^-)\nbigg \n\nso that using the relations\n\ndelta Q_ni = m_ij delta x_nj \nqquad\ndelta V_ni = fraca_ijh delta x_nj \nqquad\ndelta q_n^- = r^-_j delta x_n-1j \nqquad\ndelta q_n^+ = r^+_j delta x_nj \n\nthe discrete action principle leads to the discrete equations of motion,\n\n0 = sum limits_i=1^R b_i big h m_ij nabla vartheta (Q_ni) cdot V_ni + a_ij vartheta (Q_ni) - h m_ij nabla H(Q_ni) big \n+ r^+_j  frac vartheta ( q_n     ) + vartheta( q_n  ^+ ) 2\n- r^-_j  frac vartheta ( q_n+1^- ) + vartheta( q_n+1   ) 2\n   big \n+ h r^+_j  nabla vartheta (q_n  ^+) cdot (q_n  ^+ - q_n    )\n+ h r^-_j  nabla vartheta (q_n+1^-) cdot (q_n+1   - q_n+1^-) \n\nand\n\nvartheta(q_n^+) = vartheta (q_n^-) + nabla vartheta (q_n) cdot (q_n^+ - q_n^-) \n\nfor all n and all j. Let us introduce the variable p_n as\n\np_n = vartheta (q_n^-) + nabla vartheta (q_n) cdot (q_n - q_n^-) \n\nso that\n\nvartheta(q_n^+) = p_n + nabla vartheta (q_n) cdot (q_n^+ - q_n) \n\nThen the above equations provide a map (q_n p_n) mapsto (q_n+1 p_n+1). In order to solve these equations, initial conditions q_0 and p_0 = vartheta(q_0) have to be prescribed.\n\nFields\n\nequation: Implicit Ordinary Differential Equation\nbasis: piecewise polynomial basis\nquadrature: numerical quadrature rule\nΔt: time step\nparams: ParametersDGVI\nsolver: nonlinear solver\niguess: initial guess\nq: current solution vector for trajectory\np: current solution vector for one-form\ncache: temporary variables for nonlinear solver\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.ParametersDGVI","page":"Integrators","title":"GeometricIntegrators.Integrators.ParametersDGVI","text":"ParametersDGVI: Parameters for right-hand side function of Discontinuous Galerkin Variational Integrator.\n\nParameters\n\nDT: data type\nTT: parameter type\nD: dimension of the system\nS: number of basis nodes\nR: number of quadrature nodes\n\nFields\n\nΘ:  function of the noncanonical one-form (∂L/∂v)\nf:  function of the force (∂L/∂q)\ng:  function of the projection ∇ϑ(q)⋅v\nΔt: time step\nb:  quadrature weights\nc:  quadrature nodes\nm:  mass matrix\na:  derivative matrix\nr⁻: reconstruction coefficients, jump lhs value\nr⁺: reconstruction coefficients, jump rhs value\nt:  initial time\nq:  solution of q  at time t\nq⁻: solution of q⁻ at time t\nq⁺: solution of q⁺ at time t\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.compute_stages_p!-Union{Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{GeometricIntegrators.Integrators.IntegratorCacheDGVI{ST,D,S,R},GeometricIntegrators.Integrators.ParametersDGVI{DT,TT,D,S,R,ET} where ET<:NamedTuple}} where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.compute_stages_p!","text":"Compute one-form and forces at quadrature nodes.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.compute_stages_q!-Union{Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{GeometricIntegrators.Integrators.IntegratorCacheDGVI{ST,D,S,R},GeometricIntegrators.Integrators.ParametersDGVI{DT,TT,D,S,R,ET} where ET<:NamedTuple}} where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.compute_stages_q!","text":"Compute solution at quadrature nodes and across jump.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.compute_stages_v!-Union{Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{GeometricIntegrators.Integrators.IntegratorCacheDGVI{ST,D,S,R},GeometricIntegrators.Integrators.ParametersDGVI{DT,TT,D,S,R,ET} where ET<:NamedTuple}} where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.compute_stages_v!","text":"Compute velocities at quadrature nodes.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.ParametersDGVI{DT,TT,D,S,R,ET} where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of variational partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"integrators/dgvi/#Discontinuous-Galerkin-Variational-Integrators","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"","category":"section"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Discontinuous Galerkin Variational Integrators (DGVIs) are a family of integrators for degenerate Lagrangian systems and for Hamiltonian systems subject to Dirac constraints. For integrators for non-degenerate (regular) Lagrangian and unconstrained Hamiltonian systems see Hamilton-Pontryagin-Galerkin (HPG) Integrators.","category":"page"},{"location":"integrators/dgvi/#Degenerate-Lagrangian-Systems","page":"Discontinuous Galerkin Variational Integrators","title":"Degenerate Lagrangian Systems","text":"","category":"section"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Consider a fully degenerate Lagrangian system of the form","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"L(q dotq) = vartheta (q) cdot dotq - H(q) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"where vartheta (q) denotes the Cartan one-form and H(q) the Hamiltonian, that is usually given by the total energy of the system.","category":"page"},{"location":"integrators/dgvi/#Discrete-Trajectories-and-Numerical-Quadrature","page":"Discontinuous Galerkin Variational Integrators","title":"Discrete Trajectories and Numerical Quadrature","text":"","category":"section"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"The first step in the derivation of variational integrators is the discretization of the action integral","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"mathcalA q = int limits_0^T L(q(t) dotq(t))  dt ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"To this end, the interval 0T is split into N sub-intervals t_n t_n+1 with t_n = nh and h the time step size, so that t_N = T and the action can be written as","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"mathcalA q = sum limits_n=0^N-1 int limits_t_n t_n+1 L(q(t) dotq(t))  dt ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Within each interval (t_n t_n+1) a piecewise-polynomial approximation q_h of the trajectory q is constructed using S basis functions varphi_i,","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"q_h(t) vert_(t_n t_n+1) = sum limits_i=1^S x_ni  barvarphi_ni (t) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"where barvarphi_ni (t) is a rescaled basis function, defined by","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"barvarphi_ni (t) = varphi_i bigg( fract - t_nt_n+1 - t_n bigg) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"and it is assumed that varphi_i is compactly supported on 01. These approximations q_h(t) do not need to be continuous across interval boundaries but are indeed allowed to have jumps. Replacing the continuous trajectory q in the action with q_h, we obtain","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"mathcalA q_h = sum limits_n=0^N-1 int limits_(t_n t_n+1) big vartheta (q_h (t)) cdot dotq_h (t) - H(q_h (t)) big  dt\n+ sum limits_n=1^N-1  vartheta (q_h (t)) cdot dotq_h (t) _t=t_n  ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"The integral of the Hamiltonian H(q_h) over the interval boundaries does not contribute to the integral, differently from the term vartheta (q_h) cdot dotq_h, which will determine the numerical flux  cdot _n at t_n of the Discontinuous Galerkin method. The approximation of this term will be discussed below. In order to obtain a fully discrete action, a numerical quadrature rule with R nodes c_i and weights b_i is introduced for the approximation of the integral,","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"mathcalA_d x_d = h sum limits_n=0^N-1 sum limits_i=1^R b_i big vartheta (q_h(t_n + c_i h)) cdot dotq_h (t_n + c_i h) - H(q_h(t_n + c_i h)) big\n+ sum limits_n=1^N-1  vartheta (q_h (t)) cdot dotq_h (t) _t=t_n ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Here, x_d denotes the vector of all the degrees of freedom, i.e.,","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"x_d = ( x_01  x_0S  x_11  x_N-2S  x_N-11  x_N-1S )^T ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"In order to write the discrete action in a more explicit form, mass and derivative matrices m and a are introduced, whose elements are given by","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"m_ij = varphi_j (c_i) \nqquad\na_ij = varphi_j (c_i) \nqquad\ni = 1  R \n\nj = 1  S ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"so that the solution and its time derivative at the quadrature points can be written as","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Q_ni equiv q_h(t_n + c_i h) = m_ij x_nj \nqquad\nV_ni equiv dotq_h (t_n + c_i h) = a_ij x_nj ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"where","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"x_n = ( x_n1  x_nS )^T","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"is the vector containing the degrees of freedom of q_h vert_t_n t_n+1. Using these definitions, the discrete action can be written as","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"mathcalA_d x_d = h sum limits_n=0^N-1 sum limits_i=1^R b_i big vartheta (Q_ni) cdot V_ni - H(Q_ni) big\n+ sum limits_n=1^N-1  vartheta (q_h (t)) cdot dotq_h (t) _t=t_n ","category":"page"},{"location":"integrators/dgvi/#Numerical-Fluxes","page":"Discontinuous Galerkin Variational Integrators","title":"Numerical Fluxes","text":"","category":"section"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"In the following, the solution values \"left\" and \"right\" of the jump will be needed. This will be denoted by q_n^- and q_n^+, respectively. Usually, these just correspond to the polynomials on the left and right, evaluated at t_n, i.e.,","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"q_n^- = lim_t uparrow t_n q_h (t) = q_h vert_t_n-1 t_n (t_n) \nqquad\nq_n^+ = lim_t downarrow t_n q_h (t) = q_h vert_t_n t_n+1 (t_n) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"In principle, however, more general reconstructions of the solution could be used. In the following, it will be assumed, that q_n^- is given by some linear combinations of the degrees of freedom of the polynomial on the left interval and correspondingly that q_n^+ is given by some linear combinations of the degrees of freedom of the polynomial on the right interval, specifically","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"q_n^- = r^- cdot x_n \nqquad\nq_n^+ = r^+ cdot x_n+1 ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"where r^pm are appropriate coefficient vectors.","category":"page"},{"location":"integrators/dgvi/#Gauge-Terms","page":"Discontinuous Galerkin Variational Integrators","title":"Gauge Terms","text":"","category":"section"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"The Lagrangian L can be augmented with any total time derivative without changing the (continuous) Euler-Lagrange equations. In particular, one can consider the modified Lagrangian","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"L(q dotq) = vartheta (q) cdot dotq - H(q) - nu dfracddt bigg( vartheta (q) cdot q bigg) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"While this gauge term vanishes in the continuous case, it takes a finite value across jumps of the discontinuous discrete solution, so that the modified discrete action reads","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"mathcalA_d x_d = h sum limits_n=0^N-1 sum limits_i=1^R b_i big vartheta (Q_ni) cdot V_ni - H(Q_ni) big\n+ sum limits_n=1^N-1 biggbigg vartheta (q_h (t)) cdot dotq_h (t) - nu dfracddt bigg( vartheta (q) cdot q bigg) biggbigg_t=t_n ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"In the following, only the modified Lagrangian and action will be considered, in order to obtain a sufficiently general framework for constructing numerical fluxes. For brevity of notation, the prime will be dropped.","category":"page"},{"location":"integrators/dgvi/#Total-Time-Derivatives-Across-Jumps","page":"Discontinuous Galerkin Variational Integrators","title":"Total Time Derivatives Across Jumps","text":"","category":"section"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"The computation of the total time derivative in the gauge term is simple, at least in the distributional sense. Even though both, vartheta (q_h) and q_h have a jump, the jump occurs at the same position in time, so that the derivative can be computed as","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"dfracddt bigg( vartheta (q_h) cdot q_h bigg) biggvert_t=t_n\n= dfracddt bigg( vartheta (q_n^-) cdot q_n^-  Theta (t_n - t) + vartheta (q_n^+) cdot q_n^+  Theta (t - t_n) bigg) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"where Theta denotes the Heaviside function. This can be explicitly computed as","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"dfracddt bigg( vartheta (q_h) cdot q_h bigg) biggvert_t=t_n\n= - vartheta (q_n^-) cdot q_n^-  delta (t_n) + vartheta (q_n^+) cdot q_n^+  delta (t_n)\n=  vartheta (q_h) cdot q_h _t=t_n  delta (t_n) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"with delta (t_n) the Dirac delta-function at t_n.","category":"page"},{"location":"integrators/dgvi/#Non-conservative-Products","page":"Discontinuous Galerkin Variational Integrators","title":"Non-conservative Products","text":"","category":"section"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Simple means for integrating the Lagrangian across jumps are provided by discretisations of the integral","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"int limits_0^1 vartheta (Phi(tau q^- q^+)) cdot dfracd Phi(tau q^- q^+)dtau  dtau ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"where Phi is a path connecting the solution values q^- and q^+ on the left and the right of the jump. Upon picking a quadrature rule with sigma nodes gamma_i and corresponding weights beta_i, the discrete product takes the form","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"sum limits_i=1^sigma beta_i  vartheta big( Phi (gamma_i q_n^-  q_n^+) big) cdot dfracdPhidtau (gamma_i q_n^-  q_n^+) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"For a compact notation, \"mass\" and \"derivative\" vectors mu^pm and alpha^pm are introduced, so that","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Phi (gamma_i q_n^-  q_n^+) = mu^-_i q_n^- + mu^+_i q_n^+\nqquad\nPhi (gamma_i q_n^-  q_n^+) = alpha^-_i q_n^- + alpha^+_i q_n^+ ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"and the discrete product can be written as","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"sum limits_i=1^sigma beta_i  vartheta ( mu^-_i q_n^- + mu^+_i q_n^+ ) cdot ( alpha^-_i q_n^- + alpha^+_i q_n^+ ) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Providing the path Phi by two functions phi^pm(tau), so that","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"phi(tau q^- q^+) = q^- phi^-(tau) + q^+ phi^+(tau) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"the components of the \"mass\" and \"derivative\" vectors are given by","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"mu^-_i = phi^- (gamma_i) \nqquad\nmu^+_i = phi^+ (gamma_i) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"and","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"alpha^-_i = fracdphi^-dtau (gamma_i) \nqquad\nalpha^+_i = fracdphi^+dtau (gamma_i) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"respectively.","category":"page"},{"location":"integrators/dgvi/#Discrete-Variational-Principle","page":"Discontinuous Galerkin Variational Integrators","title":"Discrete Variational Principle","text":"","category":"section"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Using the construction of the previous sections, the discrete action reads","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"mathcalA_d x_d = h sum limits_n=0^N-1 sum limits_i=1^R b_i big vartheta (Q_ni) cdot V_ni - H(Q_ni) big \n+ sum limits_n=1^N-1 bigg sum limits_i=1^sigma beta_i  vartheta ( mu^-_i q_n^- + mu^+_i q_n^+ ) cdot ( alpha^-_i q_n^- + alpha^+_i q_n^+ )\n- nu big vartheta (q_n^+) cdot q_n^+ - vartheta (q_n^-) cdot q_n^- big bigg ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"The discrete Euler-Lagrange equations are obtained by applying Hamilton's principle of stationary action to mathcalA_d x_d, that is requiring that delta mathcalA_d x_d = 0. The variations of the discrete action are computed as follows,","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"delta mathcalA_d x_d\n= h sum limits_n=0^N-1 sum limits_i=1^R b_i big delta Q_ni cdot nabla vartheta (Q_ni) cdot V_ni + vartheta (Q_ni) cdot delta V_ni - delta Q_ni cdot nabla H(Q_ni) big \n+ sum limits_n=1^N-1 bigg sum limits_i=1^sigma beta_i  big ( mu^-_i delta q_n^- + mu^+_i delta q_n^+ ) cdot nabla vartheta ( mu^-_i q_n^- + mu^+_i q_n^+ ) cdot ( alpha^-_i q_n^- + alpha^+_i q_n^+ ) + vartheta ( mu^-_i q_n^- + mu^+_i q_n^+ ) cdot ( alpha^-_i delta q_n^- + alpha^+_i delta q_n^+ ) big \n- nu big delta q_n^+ cdot nabla vartheta (q_n^+) cdot q_n^+  + vartheta (q_n^+) cdot delta q_n^+ - delta q_n^- cdot nabla vartheta (q_n^-) cdot q_n^- - vartheta (q_n^-) cdot delta q_n^- big bigg ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Using the relations","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"delta Q_ni = m_ij delta x_nj \nqquad\ndelta V_ni = fraca_ijh delta x_nj \nqquad\ndelta q_n^- = r^-_j delta x_n-1j \nqquad\ndelta q_n^+ = r^+_j delta x_nj ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"the variations of the discrete action become","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"delta mathcalA_d x_d\n= sum limits_n=0^N-1 sum limits_i=1^R sum limits_j=1^S b_i big h m_ij delta x_nj cdot nabla vartheta (Q_ni) cdot V_ni + vartheta (Q_ni) cdot a_ij delta x_nj - h m_ij delta x_nj cdot nabla H(Q_ni) big \n+ sum limits_n=1^N-1 bigg sum limits_i=1^sigma sum limits_j=1^S beta_i  big ( mu^-_i r^-_j delta x_n-1j + mu^+_i r^+_j delta x_nj ) cdot nabla vartheta ( mu^-_i q_n^- + mu^+_i q_n^+ ) cdot ( alpha^-_i q_n^- + alpha^+_i q_n^+ ) + vartheta ( mu^-_i q_n^- + mu^+_i q_n^+ ) cdot ( alpha^-_i r^-_j delta x_n-1j + alpha^+_i r^+_j delta x_nj ) big \n- nu big r^+_j delta x_nj cdot nabla vartheta (q_n^+) cdot q_n^+  + vartheta (q_n^+) cdot r^+_j delta x_nj - r^-_j delta x_n-1j cdot nabla vartheta (q_n^-) cdot q_n^- - vartheta (q_n^-) cdot r^-_j delta x_n-1j big bigg ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Requiring the variation of the discrete action to vanish yields the discrete equations of motion,","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"0 = sum limits_i=1^R b_i big h m_ij nabla vartheta (Q_ni) cdot V_ni + a_ij vartheta (Q_ni) - h m_ij nabla H(Q_ni) big \n+ bigg sum limits_i=1^sigma beta_i  big\n   mu^-_i r^-_j nabla vartheta ( mu^-_i q_n+1^- + mu^+_i q_n+1^+ ) cdot ( alpha^-_i q_n+1^- + alpha^+_i q_n+1^+ )\n + mu^+_i r^+_j nabla vartheta ( mu^-_i q_n  ^- + mu^+_i q_n  ^+ ) cdot ( alpha^-_i q_n  ^- + alpha^+_i q_n  ^+ ) \n + vartheta ( mu^-_i q_n+1^- + mu^+_i q_n+1^+ ) alpha^-_i r^-_j\n + vartheta ( mu^-_i q_n  ^- + mu^+_i q_n  ^+ ) alpha^+_i r^+_j\n   big \n - nu big\n     r^+_j nabla vartheta (q_n  ^+) cdot q_n  ^+ + r^+_j vartheta (q_n  ^+)\n   - r^-_j nabla vartheta (q_n+1^-) cdot q_n+1^- - r^-_j vartheta (q_n+1^-)\n   big\n bigg ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"for all n and all j.","category":"page"},{"location":"modules/solutions/#Solutions","page":"Solutions","title":"Solutions","text":"","category":"section"},{"location":"modules/solutions/","page":"Solutions","title":"Solutions","text":"Modules = [GeometricIntegrators.Solutions]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolution","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Abstract atomistic or single-step solution.\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolution-Tuple{AbstractEquationDAE}","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Create AtomicSolution for DAE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolution-Tuple{AbstractEquationODE}","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Create AtomicSolution for ODE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolution-Tuple{AbstractEquationPDAE}","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Create AtomicSolution for partitioned DAE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolution-Tuple{AbstractEquationPODE}","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Create AtomicSolution for partitioned ODE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolution-Tuple{Equation}","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Print error for AtomicSolutions of equations not implemented, yet.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolution-Tuple{SolutionDAE}","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Create AtomicSolution for DAE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolution-Tuple{SolutionODE}","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Create AtomicSolution for ODE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolution-Tuple{SolutionPDAE}","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Create AtomicSolution for partitioned DAE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolution-Tuple{SolutionPODE}","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Create AtomicSolution for partitioned ODE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolution-Tuple{Solution}","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Print error for AtomicSolutions of solution not implemented, yet.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolutionDAE","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolutionDAE","text":"Atomic solution for an DAE.\n\nParameters\n\nDT: data type\nTT: time step type\nAT: array type\nIT: internal variable types\n\nFields\n\nt: time of current time step\nt̅: time of previous time step\nq: current solution of q\nq̅: previous solution of q\nq̃: compensated summation error of q\nλ: current solution of λ\nλ̅: previous solution of λ\nv: vector field of q\nv̅: vector field of q̅\nu: projective vector field of q\nu̅: projective vector field of q̅\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolutionODE","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolutionODE","text":"Atomic solution for an ODE.\n\nParameters\n\nDT: data type\nTT: time step type\nAT: array type\nIT: internal variable types\n\nFields\n\nt: time of current time step\nt̅: time of previous time step\nq: current solution of q\nq̅: previous solution of q\nq̃: compensated summation error of q\nv: vector field of q\nv̅: vector field of q̅\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolutionPDAE","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolutionPDAE","text":"Atomic solution for an PDAE.\n\nParameters\n\nDT: data type\nTT: time step type\nAT: array type\nIT: internal variable types\n\nFields\n\nt: time of current time step\nt̅: time of previous time step\nq: current solution of q\nq̅: previous solution of q\nq̃: compensated summation error of q\np: current solution of p\np̅: previous solution of p\np̃: compensated summation error of p\nλ: current solution of λ\nλ̅: previous solution of λ\nv: vector field of q\nv̅: vector field of q̅\nf: vector field of p\nf̅: vector field of p̅\nu: projective vector field of q\nu̅: projective vector field of q̅\ng: projective vector field of p\ng̅: projective vector field of p̅\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolutionPODE","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolutionPODE","text":"Atomic solution for an PODE.\n\nParameters\n\nDT: data type\nTT: time step type\nAT: array type\nIT: internal variable types\n\nFields\n\nt: time of current time step\nt̅: time of previous time step\nq: current solution of q\nq̅: previous solution of q\nq̃: compensated summation error of q\np: current solution of p\np̅: previous solution of p\np̃: compensated summation error of p\nv: vector field of q\nv̅: vector field of q̅\nf: vector field of p\nf̅: vector field of p̅\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.Solution-Tuple{AbstractEquationDAE,Any,Int64}","page":"Solutions","title":"GeometricIntegrators.Solutions.Solution","text":"Create solution for DAE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.Solution-Tuple{AbstractEquationODE,Any,Int64}","page":"Solutions","title":"GeometricIntegrators.Solutions.Solution","text":"Create solution for ODE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.Solution-Tuple{AbstractEquationPDAE,Any,Int64}","page":"Solutions","title":"GeometricIntegrators.Solutions.Solution","text":"Create solution for partitioned DAE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.Solution-Tuple{AbstractEquationPODE,Any,Int64}","page":"Solutions","title":"GeometricIntegrators.Solutions.Solution","text":"Create solution for partitioned ODE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.Solution-Tuple{Equation,Any,Int64}","page":"Solutions","title":"GeometricIntegrators.Solutions.Solution","text":"Print error for solutions of equations not implemented, yet.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.SolutionDAE","page":"Solutions","title":"GeometricIntegrators.Solutions.SolutionDAE","text":"SolutionDAE: Solution of a differential algebraic equation\n\nContains all fields necessary to store the solution of an DAE.\n\nFields\n\nnd: dimension of the dynamical variable q\nnm: dimension of the constraint submanifold\nnt: number of time steps to store\nni: number of initial conditions\nt:  time steps\nq:  solution q[nd, nt+1, ni] with q[:,0,:] the initial conditions\nλ:  Lagrange multiplier λ[nd, nt+1, ni]\nntime: number of time steps to compute\nnsave: store every nsave'th time step (default: 1)\nnwrite: save data to disk after every nwrite'th time step (default: ntime)\ncounter: counter for copied solution entries\nwoffset: counter for file offset\nh5: HDF5 file for storage\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.SolutionODE","page":"Solutions","title":"GeometricIntegrators.Solutions.SolutionODE","text":"SolutionODE: Solution of an ordinary differential equation\n\nContains all fields necessary to store the solution of an ODE.\n\nFields\n\nnd: dimension of the dynamical variable q\nnt: number of time steps to store\nni: number of initial conditions\nt:  time steps\nq:  solution q[nd, nt+1, ni] with q[:,0,:] the initial conditions\nntime: number of time steps to compute\nnsave: store every nsave'th time step (default: 1)\nnwrite: save data to disk after every nwrite'th time step (default: ntime)\ncounter: counter for copied solution entries\nwoffset: counter for file offset\nh5: HDF5 file for storage\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.SolutionPDAE","page":"Solutions","title":"GeometricIntegrators.Solutions.SolutionPDAE","text":"SolutionPDAE: Solution of a partitioned differential algebraic equation\n\nContains all fields necessary to store the solution of an PDAE.\n\nFields\n\nnd: dimension of the dynamical variable q\nnm: dimension of the constraint submanifold\nnt: number of time steps to store\nni: number of initial conditions\nt:  time steps\nq:  solution q[nd, nt+1, ni] with q[:,0,:] the initial conditions\np:  solution p[nd, nt+1, ni] with p[:,0,:] the initial conditions\nλ:  Lagrange multiplier λ[nd, nt+1, ni]\nntime: number of time steps to compute\nnsave: store every nsave'th time step (default: 1)\nnwrite: save data to disk after every nwrite'th time step (default: ntime)\ncounter: counter for copied solution entries\nwoffset: counter for file offset\nh5: HDF5 file for storage\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.SolutionPODE","page":"Solutions","title":"GeometricIntegrators.Solutions.SolutionPODE","text":"SolutionPODE: Solution of a partitioned ordinary differential equation\n\nContains all fields necessary to store the solution of an PODE.\n\nFields\n\nnd: dimension of the dynamical variable q\nnt: number of time steps to store\nni: number of initial conditions\nt:  time steps\nq:  solution q[nd, nt+1, ni] with q[:,0,:] the initial conditions\np:  solution p[nd, nt+1, ni] with p[:,0,:] the initial conditions\nntime: number of time steps to compute\nnsave: store every nsave'th time step (default: 1)\nnwrite: save data to disk after every nwrite'th time step (default: ntime)\ncounter: counter for copied solution entries\nwoffset: counter for file offset\nh5: HDF5 file for storage\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Common.write_to_hdf5","page":"Solutions","title":"GeometricIntegrators.Common.write_to_hdf5","text":"Append solution to HDF5 file.\n\n\n\n\n\n","category":"function"},{"location":"modules/solutions/#GeometricIntegrators.Common.write_to_hdf5-2","page":"Solutions","title":"GeometricIntegrators.Common.write_to_hdf5","text":"Append solution to HDF5 file.\n\n\n\n\n\n","category":"function"},{"location":"modules/solutions/#GeometricIntegrators.Common.write_to_hdf5-Tuple{Solution,AbstractString}","page":"Solutions","title":"GeometricIntegrators.Common.write_to_hdf5","text":"Creates HDF5 file, writes solution to file, and closes file.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Common.write_to_hdf5-Tuple{Solution}","page":"Solutions","title":"GeometricIntegrators.Common.write_to_hdf5","text":"writetohdf5: Wrapper for saving Solution to HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.ParallelSolution-Tuple{AbstractEquationDAE,Any,Int64}","page":"Solutions","title":"GeometricIntegrators.Solutions.ParallelSolution","text":"Create parallel solution for DAE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.ParallelSolution-Tuple{AbstractEquationODE,Any,Int64}","page":"Solutions","title":"GeometricIntegrators.Solutions.ParallelSolution","text":"Create parallel solution for ODE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.ParallelSolution-Tuple{AbstractEquationPDAE,Any,Int64}","page":"Solutions","title":"GeometricIntegrators.Solutions.ParallelSolution","text":"Create parallel solution for partitioned DAE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.ParallelSolution-Tuple{AbstractEquationPODE,Any,Int64}","page":"Solutions","title":"GeometricIntegrators.Solutions.ParallelSolution","text":"Create parallel solution for partitioned ODE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.ParallelSolution-Tuple{Equation,Any,Int64}","page":"Solutions","title":"GeometricIntegrators.Solutions.ParallelSolution","text":"Print error for parallel solutions of equations not implemented, yet.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.copy_solution!-Tuple{Solution,AtomicSolution,Any,Any}","page":"Solutions","title":"GeometricIntegrators.Solutions.copy_solution!","text":"Copy solution from atomistic solution to solution object.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.createHDF5-Tuple{Solution,AbstractString}","page":"Solutions","title":"GeometricIntegrators.Solutions.createHDF5","text":"createHDF5: Creates or opens HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.create_hdf5!-Tuple{Solution,AbstractString}","page":"Solutions","title":"GeometricIntegrators.Solutions.create_hdf5!","text":"Creates HDF5 file and initialises datasets for solution object.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.create_hdf5-Tuple{DeterministicSolution,AbstractString}","page":"Solutions","title":"GeometricIntegrators.Solutions.create_hdf5","text":"Creates HDF5 file and initialises datasets for deterministic solution object.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.save_attributes-Tuple{DeterministicSolution,HDF5.File}","page":"Solutions","title":"GeometricIntegrators.Solutions.save_attributes","text":"save_attributes: Saves attributes of Deterministic Solutions to HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.save_attributes-Tuple{Solution}","page":"Solutions","title":"GeometricIntegrators.Solutions.save_attributes","text":"save_attributes: Saves common attributes of Solution to HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/splitting/#Splitting-Tableaus","page":"Splitting Methods","title":"Splitting Tableaus","text":"","category":"section"},{"location":"tableaus/splitting/","page":"Splitting Methods","title":"Splitting Methods","text":"Modules = [GeometricIntegrators.Tableaus]\nPages   = [\"tableaus/tableaus_splitting.jl\"]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"tableaus/splitting/#GeometricIntegrators.Tableaus.TableauLieA-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Splitting Methods","title":"GeometricIntegrators.Tableaus.TableauLieA","text":"Lie-Trotter Splitting A\n\nFor a vector field dotx = f_1 (tx) +  f_2 (tx), the splitting reads\n\nPhi_Delta t = varphi^2_Delta t circ varphi^1_Delta t\n\nReference:\n\nH. F. Trotter.\nOn the product of semi-groups of operators.\nProceedings of the American Mathematical Society, Volume 10, Pages 545-551, 1959.\ndoi: 10.1090/S0002-9939-1959-0108732-6.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/splitting/#GeometricIntegrators.Tableaus.TableauLieB-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Splitting Methods","title":"GeometricIntegrators.Tableaus.TableauLieB","text":"Lie-Trotter Splitting B\n\nFor a vector field dotx = f_1 (tx) +  f_2 (tx), the splitting reads\n\nPhi_Delta t = varphi^1_Delta t circ varphi^2_Delta t\n\nReference:\n\nH. F. Trotter.\nOn the product of semi-groups of operators.\nProceedings of the American Mathematical Society, Volume 10, Pages 545-551, 1959.\ndoi: 10.1090/S0002-9939-1959-0108732-6.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/splitting/#GeometricIntegrators.Tableaus.TableauMarchuk","page":"Splitting Methods","title":"GeometricIntegrators.Tableaus.TableauMarchuk","text":"Alias for TableauStrang\n\n\n\n\n\n","category":"function"},{"location":"tableaus/splitting/#GeometricIntegrators.Tableaus.TableauMcLachlan2-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Splitting Methods","title":"GeometricIntegrators.Tableaus.TableauMcLachlan2","text":"McLachlan's 2nd order symmetric, minimum error composition method\n\nThe composition reads\n\nPhi_Delta t = varphi_alpha Delta t circ varphi^*_(12 - alpha) Delta t circ varphi_(12 - alpha) Delta t circ varphi^*_alpha Delta t \n\nwhere the parameter alpha can be optimized, e.g., to minimize the solution error. McLachlan arrives at alpha  = 01932 as a generally useful value.\n\nReference:\n\nRobert I. McLachlan.\nOn the Numerical Integration of Ordinary Differential Equations by Symmetric Composition Methods\nSIAM Journal on Scientific Computing, Volume 16, Pages 151-168, 1995.\ndoi: 10.1137/0916010.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/splitting/#GeometricIntegrators.Tableaus.TableauMcLachlan4-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Splitting Methods","title":"GeometricIntegrators.Tableaus.TableauMcLachlan4","text":"McLachlan's 4th order symmetric, minimum error composition method\n\nThe composition reads\n\nPhi_Delta t = varphi_alpha_5 Delta t circ varphi^*_beta_5 Delta t circ dotsc circ varphi_alpha_2 Delta t circ varphi^*_beta_2 Delta t circ varphi_alpha_1 Delta t circ varphi^*_beta_1 Delta t \n\nwith\n\nbeginaligned\nbeta_1 = alpha_5 = frac14 - sqrt19108  \nalpha_1 = beta_5 = frac146 + 5 sqrt19540    \nbeta_2 = alpha_4 = frac- 23 - 20 sqrt19270  \nalpha_2 = beta_4 = frac-2 + 10 sqrt19135   \nbeta_3 = alpha_3 = frac15 \nendaligned\n\nThe coefficients are optimised to provide an integrator with minimal solution error.\n\nReference:\n\nRobert I. McLachlan.\nOn the Numerical Integration of Ordinary Differential Equations by Symmetric Composition Methods\nSIAM Journal on Scientific Computing, Volume 16, Pages 151-168, 1995.\ndoi: 10.1137/0916010.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/splitting/#GeometricIntegrators.Tableaus.TableauStrang-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Splitting Methods","title":"GeometricIntegrators.Tableaus.TableauStrang","text":"Strang Splitting\n\nFor a vector field dotx = f_1 (tx) + f_2 (tx), the splitting reads\n\nPhi_Delta t = varphi^1_Delta t  2 circ varphi^2_Delta t  2 circ varphi^2_Delta t  2 circ varphi^1_Delta t  2\n\nFor vector fields with two components, this is not the most efficient implementation. For such cases TableauStrangA or TableauStrangB should be used instead.\n\nReferences:\n\nGilbert Strang.\nOn the construction and comparison of difference schemes.\nSIAM Journal on Numerical Analysis, Volume 5, Pages 506-517, 1968.\ndoi: 10.1137/0705041.\n\nGurij Ivanovich Marchuk.\nSome applications of splitting-up methods to the solution of mathematical physics problems.\nAplikace Matematiky, Volume 13, Pages 103-132, 1968.\ndoi: 10.21136/AM.1968.103142.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/splitting/#GeometricIntegrators.Tableaus.TableauStrangA-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Splitting Methods","title":"GeometricIntegrators.Tableaus.TableauStrangA","text":"Strang Splitting A for a vector field dotx = f_1 (tx) + f_2 (tx).\n\nThe splitting reads\n\nPhi_Delta t = varphi^1_Delta t  2 circ varphi^2_Delta t circ varphi^1_Delta t  2\n\nReferences:\n\nGilbert Strang.\nOn the construction and comparison of difference schemes.\nSIAM Journal on Numerical Analysis, Volume 5, Pages 506-517, 1968.\ndoi: 10.1137/0705041.\n\nGurij Ivanovich Marchuk.\nSome applications of splitting-up methods to the solution of mathematical physics problems.\nAplikace Matematiky, Volume 13, Pages 103-132, 1968.\ndoi: 10.21136/AM.1968.103142.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/splitting/#GeometricIntegrators.Tableaus.TableauStrangB-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Splitting Methods","title":"GeometricIntegrators.Tableaus.TableauStrangB","text":"Strang Splitting B for a vector field dotx = f_1 (tx) + f_2 (tx)\n\nThe splitting reads\n\nPhi_Delta t = varphi^2_Delta t  2 circ varphi^1_Delta t circ varphi^2_Delta t  2\n\nReferences:\n\nGilbert Strang.\nOn the construction and comparison of difference schemes.\nSIAM Journal on Numerical Analysis, Volume 5, Pages 506-517, 1968.\ndoi: 10.1137/0705041.\n\nGurij Ivanovich Marchuk.\nSome applications of splitting-up methods to the solution of mathematical physics problems.\nAplikace Matematiky, Volume 13, Pages 103-132, 1968.\ndoi: 10.21136/AM.1968.103142.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/splitting/#GeometricIntegrators.Tableaus.TableauSuzukiFractal-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Splitting Methods","title":"GeometricIntegrators.Tableaus.TableauSuzukiFractal","text":"Suzuki's 4th order \"fractal\" composition method\n\nThe composition reads\n\nPhi_Delta t = varphi_gamma_5 Delta t circ varphi_gamma_4 Delta t circ varphi_gamma_3 Delta t circ varphi_gamma_2 Delta t circ varphi_gamma_1 Delta t\n\nwith\n\ngamma_1 = gamma_2 = gamma_4 = gamma_5 = frac14 - 4^1(p+1)  qquad\ngamma_3 = - frac4^1(p+1)4 - 4^1(p+1) \n\nReference:\n\nMasuo Suzuki\nFractal decomposition of exponential operators with applications to many-body theories and Monte Carlo simulations.\nPhysics Letters A, Volume 146, Pages 319-323, 1990.\ndoi: 10.1016/0375-9601(90)90962-N\n\n\n\n\n\n","category":"method"},{"location":"tableaus/splitting/#GeometricIntegrators.Tableaus.TableauTripleJump-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Splitting Methods","title":"GeometricIntegrators.Tableaus.TableauTripleJump","text":"4th order \"Triple Jump\" composition method.\n\nThe composition reads\n\nPhi_Delta t = varphi_gamma_3 Delta t circ varphi_gamma_2 Delta t circ varphi_gamma_1 Delta t\n\nwith\n\ngamma_1 = gamma_3 = frac12 - 2^1(p+1)  qquad\ngamma_2 = - frac2^1(p+1)2 - 2^1(p+1) \n\nReferences:\n\nMichael Creutz and Andreas Gocksch.\nHigher-order hybrid Monte Carlo algorithms.\nPhysical Review Letters, Volume 63, Pages 9-12, 1989.\ndoi: 10.1103/PhysRevLett.63.9.\n\nEtienne Forest.\nCanonical integrators as tracking codes (or how to integrate perturbation theory with tracking).\nAIP Conference Proceedings, Volume 184, Pages 1106-1136, 1989.\ndoi: 10.1063/1.38062.\n\nMasuo Suzuki\nFractal decomposition of exponential operators with applications to many-body theories and Monte Carlo simulations.\nPhysics Letters A, Volume 146, Pages 319-323, 1990.\ndoi: 10.1016/0375-9601(90)90962-N\n\nHaruo Yoshida.\nConstruction of higher order symplectic integrators.\nPhysics Letters A, Volume 150, Pages 262-268, 1990.\ndoi: 10.1016/0375-9601(90)90092-3\n\n\n\n\n\n","category":"method"},{"location":"tableaus/vprk/#Variational-Partitioned-Runge-Kutta-Tableaus","page":"VPRK Methods","title":"Variational Partitioned Runge-Kutta Tableaus","text":"","category":"section"},{"location":"tableaus/vprk/","page":"VPRK Methods","title":"VPRK Methods","text":"Modules = [GeometricIntegrators.Tableaus]\nPages   = [\"tableaus/tableaus_vprk.jl\"]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"tableaus/vprk/#GeometricIntegrators.Tableaus.TableauVPGLRK-Tuple{Any}","page":"VPRK Methods","title":"GeometricIntegrators.Tableaus.TableauVPGLRK","text":"Tableau for variational Gauss-Legendre method with s stages\n\nUses Gauss coefficients for both a_ij and bara_ij.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/vprk/#GeometricIntegrators.Tableaus.TableauVPLobattoIIIA-Tuple{Any}","page":"VPRK Methods","title":"GeometricIntegrators.Tableaus.TableauVPLobattoIIIA","text":"Tableau for variational Lobatto IIIA method with s stages\n\nUses Lobatto IIIA for the coefficients a_ij and its symplectic conjugate, Lobatto IIIB, for the coefficients bara_ij.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/vprk/#GeometricIntegrators.Tableaus.TableauVPLobattoIIIAIIIA-Tuple{Any}","page":"VPRK Methods","title":"GeometricIntegrators.Tableaus.TableauVPLobattoIIIAIIIA","text":"Tableau for an implicit partitioned Lobatto IIIA Runge-Kutta method with s stages\n\nUses Lobatto IIIA for both coefficients a_ij and bara_ij.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/vprk/#GeometricIntegrators.Tableaus.TableauVPLobattoIIIB-Tuple{Any}","page":"VPRK Methods","title":"GeometricIntegrators.Tableaus.TableauVPLobattoIIIB","text":"Tableau for variational Lobatto IIIB method with s stages\n\nUses Lobatto IIIB for the coefficients a_ij and its symplectic conjugate, Lobatto IIIA, for the coefficients bara_ij.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/vprk/#GeometricIntegrators.Tableaus.TableauVPLobattoIIIBIIIB-Tuple{Any}","page":"VPRK Methods","title":"GeometricIntegrators.Tableaus.TableauVPLobattoIIIBIIIB","text":"Tableau for an implicit partitioned Lobatto IIIB Runge-Kutta method with s stages\n\nUses Lobatto IIIB for both coefficients a_ij and bara_ij.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/vprk/#GeometricIntegrators.Tableaus.TableauVPLobattoIIIC-Tuple{Any}","page":"VPRK Methods","title":"GeometricIntegrators.Tableaus.TableauVPLobattoIIIC","text":"Tableau for variational Lobatto IIIC method with s stages\n\nUses Lobatto IIIC for the coefficients a_ij and its symplectic conjugate, Lobatto IIIC̄, for the coefficients bara_ij.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/vprk/#GeometricIntegrators.Tableaus.TableauVPLobattoIIIC̄-Tuple{Any}","page":"VPRK Methods","title":"GeometricIntegrators.Tableaus.TableauVPLobattoIIIC̄","text":"Tableau for variational Lobatto IIIC̄ method with s stages\n\nUses Lobatto IIIC̄ for the coefficients a_ij and its symplectic conjugate, Lobatto IIIC, for the coefficients bara_ij.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/vprk/#GeometricIntegrators.Tableaus.TableauVPLobattoIIID-Tuple{Any}","page":"VPRK Methods","title":"GeometricIntegrators.Tableaus.TableauVPLobattoIIID","text":"Tableau for variational Lobatto IIID method with s stages\n\nUses Lobatto IIID for both coefficients a_ij and bara_ij.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/vprk/#GeometricIntegrators.Tableaus.TableauVPLobattoIIIE-Tuple{Any}","page":"VPRK Methods","title":"GeometricIntegrators.Tableaus.TableauVPLobattoIIIE","text":"Tableau for variational Lobatto IIIE method with s stages\n\nUses Lobatto IIIE for both coefficients a_ij and bara_ij.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/vprk/#GeometricIntegrators.Tableaus.TableauVPLobattoIIIF-Tuple{Any}","page":"VPRK Methods","title":"GeometricIntegrators.Tableaus.TableauVPLobattoIIIF","text":"Tableau for variational Lobatto IIIF method with s stages\n\nUses Lobatto IIIF for the coefficients a_ij and its symplectic conjugate for the coefficients bara_ij.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/vprk/#GeometricIntegrators.Tableaus.TableauVPLobattoIIIG-Tuple{Any}","page":"VPRK Methods","title":"GeometricIntegrators.Tableaus.TableauVPLobattoIIIG","text":"Tableau for variational Lobatto IIIG method with s stages\n\nUses Lobatto IIIG for both coefficients a_ij and bara_ij.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/vprk/#GeometricIntegrators.Tableaus.TableauVPRadauIIAIIA-Tuple{Any}","page":"VPRK Methods","title":"GeometricIntegrators.Tableaus.TableauVPRadauIIAIIA","text":"Tableau for an implicit partitioned Radau IIA Runge-Kutta method with s stages\n\nUses Radau IIA for both coefficients a_ij and bara_ij.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/vprk/#GeometricIntegrators.Tableaus.TableauVPSRK3-Tuple{}","page":"VPRK Methods","title":"GeometricIntegrators.Tableaus.TableauVPSRK3","text":"Tableau for variational symmetric Runge-Kutta method with 3 stages\n\nUses SRK3 coefficients for both a_ij and bara_ij.\n\n\n\n\n\n","category":"method"},{"location":"modules/discontinuities/#Discontinuities","page":"Discontinuities","title":"Discontinuities","text":"","category":"section"},{"location":"modules/discontinuities/","page":"Discontinuities","title":"Discontinuities","text":"Modules = [GeometricIntegrators.Discontinuities]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"modules/discontinuities/#GeometricIntegrators.Discontinuities.PathIntegralLinear","page":"Discontinuities","title":"GeometricIntegrators.Discontinuities.PathIntegralLinear","text":"PathIntegralLinear is a path integral along a linear path\n\nphi (tau q^- q^+) = (1-tau) q^- + tau q^+ \n\n\n\n\n\n","category":"type"},{"location":"modules/discontinuities/#GeometricIntegrators.Discontinuities.PathIntegralTrigonometric","page":"Discontinuities","title":"GeometricIntegrators.Discontinuities.PathIntegralTrigonometric","text":"PathIntegralTrigonometric is a path integral along a cos^2/sin^2 path\n\nphi (tau q^- q^+) = cos^2 (pi tau  2) q^- + sin^2 (pi tau  2) q^+ \n\n\n\n\n\n","category":"type"},{"location":"integrators/stochastic/#Stochastic-Integrators","page":"Stochastic Integrators","title":"Stochastic Integrators","text":"","category":"section"},{"location":"modules/interpolation/#Interpolation","page":"Interpolation","title":"Interpolation","text":"","category":"section"},{"location":"modules/interpolation/","page":"Interpolation","title":"Interpolation","text":"Modules = [GeometricIntegrators.Interpolation]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"modules/interpolation/#GeometricIntegrators.Interpolation.HermiteInterpolation","page":"Interpolation","title":"GeometricIntegrators.Interpolation.HermiteInterpolation","text":"Hermite's Interpolating Polynomials\n\nHere, we implement a two point Hermite interpolation function which passes through the function and its first derivative for the interval 01. The polynomial is determined by four constraint equations, matching the function and its derivative at the points 0 and 1.\n\nStart by defining the 3rd degree polynomial and its derivative by\n\nbeginaligned\ng(x) = a_0 + a_1 x + a_2 x^2 + a_3 x^3  \ng(x) = a_1 + 2 a_2 x + 3 a_3 x^2 \nendaligned\n\nand apply the constraints\n\nbeginaligned\ng(0) = f_0   Rightarrow  a_0 = f_0  \ng(1) = f_1   Rightarrow  a_0 + a_1 + a_2 + a_3 = f_1  \ng(0) = f_0   Rightarrow  a_1 = f_0  \ng(1) = f_1   Rightarrow  a_1 + 2 a_2 + 3 a_3 = f_1  \nendaligned\n\nSolving for a_0 a_1 a_2 a_3 leads to\n\nbeginaligned\na_0 = f_0  \na_1 = f_0  \na_2 = - 3 f_0 + 3 f_1 - 2 f_0 - f_1  \na_3 = 2 f_0 - 2 f_1 + f_0 + f_1 \nendaligned\n\nso that the polynomial g(x) reads\n\ng(x) = f_0 + f_0 x + (- 3 f_0 + 3 f_1 - 2 f_0 - f_1) x^2 + (2 f_0 - 2 f_1 + f_0 + f_1) x^3 \n\nThe function and derivative values can be factored out, so that g(x) can be rewritten as\n\ng(x) = f_0 (1 - 3 x^2 + 2 x^3) + f_1 (3 x^2 - 2 x^3) + f_0 (x - 2 x^2 + x^3) + f_1 (- x^2 + x^3) \n\nor in generic form as\n\ng(x) = f_0 a_0(x) + f_1 a_1(x) + f_0 b_0(x) + f_1 b_1(x) \n\nwith basis functions\n\nbeginaligned\na_0 (x) = 1 - 3 x^2 + 2 x^3  \nb_0 (x) = x - 2 x^2 + x^3  \na_1 (x) = 3 x^2 - 2 x^3  \nb_1 (x) = - x^2 + x^3 \nendaligned\n\nThe derivative g(x) accordingly reads\n\ng(x) = f_0 a_0(x) + f_1 a_1(x) + f_0 b_0(x) + f_1 b_1(x) \n\nwith\n\nbeginaligned\na_0 (x) = - 6 x + 6 x^2  \nb_0 (x) = 1 - 4 x + 3 x^2  \na_1 (x) = 6 x - 6 x^2  \nb_1 (x) = - 2 x + 3 x^2 \nendaligned\n\nThe basis functions a_0and a_1 are associated with the function values at x_0 and x_1, respectively, while the basis functions b_0 and b_1 are associated with the derivative values at x_0 and x_1. The basis functions satisfy the following relations,\n\nbeginaligned\na_i (x_j) = delta_ij  \nb_i (x_j) = 0  \na_i (x_j) = 0  \nb_i (x_j) = delta_ij  \nij = 0 1 \nendaligned\n\nwhere delta_ij denotes the Kronecker-delta, so that\n\nbeginaligned\ng(0) = f_0  \ng(1) = f_1  \ng(0) = f_0  \ng(1) = f_1 \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/#Modules","page":"Modules","title":"Modules","text":"","category":"section"},{"location":"modules/","page":"Modules","title":"Modules","text":"Pages = [\"modules/discontinuities.md\",\n         \"modules/equations.md\",\n         \"modules/solutions.md\",\n         \"modules/integrators.md\",\n         \"modules/interpolation.md\",\n         \"modules/simulations.md\",\n         \"modules/tableaus.md\",\n         \"modules/rungekutta.md\"]\nDepth = 3","category":"page"},{"location":"releasenotes/#Release-Notes","page":"Release Notes","title":"Release Notes","text":"","category":"section"},{"location":"releasenotes/#.7.0","page":"Release Notes","title":"0.7.0","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"use CompactBasisFunctions.jl instead of BasisFunctions submodule\nuse QuadratureRules.jl instead of Quadratures submodule\nUse SimpleSolvers.jl instead of Solvers submodule\nUse GeometricProblems.jl instead of TestProblems submodule","category":"page"},{"location":"releasenotes/#.6.2","page":"Release Notes","title":"0.6.2","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Bugfix release","category":"page"},{"location":"releasenotes/#.6.1","page":"Release Notes","title":"0.6.1","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Bugfix release","category":"page"},{"location":"releasenotes/#.6.0","page":"Release Notes","title":"0.6.0","text":"","category":"section"},{"location":"releasenotes/#Breaking-Changes","page":"Release Notes","title":"Breaking Changes","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Revise tableaus: align constructor names with RungeKutta.jl","category":"page"},{"location":"releasenotes/#New-Features","page":"Release Notes","title":"New Features","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Add new Runge-Kutta tableaus\nGeneralise Lobatto and Radau tableaus to arbitrary number of stages\nExtend documentation on integrators and tableaus","category":"page"},{"location":"releasenotes/#.5.1","page":"Release Notes","title":"0.5.1","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Update documentation\nFix HDF5 v0.14 deprecations","category":"page"},{"location":"releasenotes/#.5.0","page":"Release Notes","title":"0.5.0","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Moved repository to JuliaGNI\nMoved CI from Travis to GitHub","category":"page"},{"location":"releasenotes/#Breaking-Changes-2","page":"Release Notes","title":"Breaking Changes","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Functions for initial guesses are now called v̄ and f̄ and can be prescribed separately from v and f in PDAE, HDAE, etc.\nRename SPARK tableau constructors and unify distinct constructors for Lobatto tableaus with different number of stages","category":"page"},{"location":"releasenotes/#New-Features-2","page":"Release Notes","title":"New Features","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Implement SPARK integrator for index-two DAEs\nImplement infrastructure for storing internal variables and solver output to atomic solutions\nStore internal variables of SPARK and VPRK integrators in atomic solution\nAdd various five-stage Lobatto tableaus\nAdd and clean up SPARK tableaus and add docstrings\nAdd functions for checking symplecticity conditions of SPARK tableaus\nAdd Aqua.jl tests","category":"page"},{"location":"releasenotes/#Fixes","page":"Release Notes","title":"Fixes","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Fix initial guess warnings in tests by prescribing proper functions for v̄ and f̄ in example problems\nFix update_multiplier() method for SPARK integrators","category":"page"},{"location":"releasenotes/#.4.1","page":"Release Notes","title":"0.4.1","text":"","category":"section"},{"location":"releasenotes/#New-Features-3","page":"Release Notes","title":"New Features","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Atomic solutions can now store a NamedTuple of internal variables of the integrator, including nonlinear solver output\nOutput of internal variables has been added to VPRK integrators\nAdd Gauss-Legendre tableaus for implicit partitioned Runge-Kutta methods","category":"page"},{"location":"releasenotes/#Fixes-2","page":"Release Notes","title":"Fixes","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Revision of integrator type hierarchy","category":"page"},{"location":"releasenotes/#.4.0","page":"Release Notes","title":"0.4.0","text":"","category":"section"},{"location":"releasenotes/#New-Integrators","page":"Release Notes","title":"New Integrators","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Runge-Kutta integrators for implicit ODEs (FIRKimplicit and SRKimplicit)\nVariational Partitioned Runge-Kutta integrator with projection based on internal stages","category":"page"},{"location":"releasenotes/#Fixes-3","page":"Release Notes","title":"Fixes","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Computation of initial guess in all implicit integrators","category":"page"},{"location":"integrators/hpg/#Hamilton-Pontryagin-Galerkin-Integrators","page":"Hamilton-Pontryagin-Galerkin Integrators","title":"Hamilton-Pontryagin-Galerkin Integrators","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"CurrentModule = GeometricIntegrators","category":"page"},{"location":"tutorial/tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"In this tutorial, we try to give an overview of the basic usage of GeometricIntegrators and its main components.","category":"page"},{"location":"tutorial/tutorial/#Installation","page":"Tutorial","title":"Installation","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"GeometricIntegrators.jl can be installed using Julia's built-in package manager in the command line interface by","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> ]\n(v1.5) pkg> add GeometricIntegrators","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"In a Jupyter notebook, GeometricIntegrators.jl can be installed by explicitly using the Pkg module as","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"using Pkg\nPkg.add(\"GeometricIntegrators\")","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"This will install the library itself as well as all dependencies.","category":"page"},{"location":"tutorial/tutorial/#Basic-usage","page":"Tutorial","title":"Basic usage","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"In the simplest cases, the use of GeometricIntegrators.jl requires the construction of two objects, an equation and an integrator. For many standard methods, the integrator is implicitly selected by specifying an equation and a tableau.","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Before any use, we need to load GeometricIntegrators,","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"using GeometricIntegrators","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Then we can create an ODE object for the equation dotx (t) = x(t) with initial condition x(0) = 1,","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"ode = ODE((t, x, ẋ) -> ẋ[1] = x[1], [1.0]);","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"create an integrator for this ODE, using the tableau for the explicit Euler method and a time step of Delta t = 01,","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"int = Integrator(ode, TableauExplicitEuler(), 0.1);","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"and compute the solution for n_t = 10 time steps,","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"sol = integrate(ode, int, 10);","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Plot and compare with the exact solution","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"using Plots\nplot(xlims=[0,1], xlab=\"t\", ylab=\"x(t)\", legend=:bottomright)\nplot!(sol.t, sol.q[1,:], label=\"numeric\")\nplot!(sol.t, exp.(sol.t), label=\"exact\")","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/tutorial/#Equations","page":"Tutorial","title":"Equations","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"In GeometricIntegrators.jl we distinguish between three basic types of equations:","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"ordinary differential equations (ODEs),\ndifferential algebraic equations (DAEs),\nstochastic differential equations (SDEs).","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"For each type, there are several subtypes","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"\"normal\" equations (ODE, DAE, SDE),\nimplicit equations (IODE, IDAE),\nvariational equations (VODE, VDAE),\nHamiltonian equations (HODE, HDAE),\npartitioned equations (PODE, PDAE, PSDE),\nsplit equations (SODE, SPDAE).","category":"page"},{"location":"tutorial/tutorial/#Ordinary-differential-equations","page":"Tutorial","title":"Ordinary differential equations","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Consider an ODE of the form","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"dotx (t) = f(t x(t)) ","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"where dotx denotes the derivative of x and f the vector field of the equation, which is assumed to depend on both t and x. In the following, we will solve the mathematical pendulum, whose equations are given by","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"beginpmatrix\ndotx_1 \ndotx_2 \nendpmatrix\n=\nbeginpmatrix\nx_2 \nsin (x_1) \nendpmatrix ","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Creating an ODE object requires the prescription of a function that computes the vector field f, e.g.,","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"function ẋ(t, x, v)\n    v[1] = x[2]\n    v[2] = sin(x[1])\nend","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"ẋ (generic function with 1 method)","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"which has to take three arguments, the current time t, the current solution vector x and the output vector f. Moreover, we need a set of initial conditions,","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"x₀ = [acos(0.4), 0.0]","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"2-element Array{Float64,1}:\n 1.1592794807274085\n 0.0","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"An ODE object is than instantiated by","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"ODE(<vector field>, <initial conditions>; kwargs...)","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"specifically,","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"ode = ODE(ẋ, x₀);","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"The initial time, ode.t₀ is assumed to be 0 be default. It can also be specified explicitly by","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"t₀  = 1.0\node = ODE(ẋ, t₀, x₀);","category":"page"},{"location":"tutorial/tutorial/#Partitioned-ordinary-differential-equations","page":"Tutorial","title":"Partitioned ordinary differential equations","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"The pendulum problem is a Hamiltonian system that can also be expressed as","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"dotq = fracpartial Hpartial p = p \nhspace3em\ndotp = - fracpartial Hpartial q = sin (q) \nhspace3em\nH (qp) = frac12 p^2 + cos (q) ","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"This structure, namely the partitioning into two sets of variables (qp) instead of x, can be exploited for more efficient integration. Such equations can be defined in terms of a partitioned ODE, where the vector fields are specified separately,","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"function q̇(t, q, p, v)\n    v[1] = p[1]\nend\n\nfunction ṗ(t, q, p, f)\n    f[1] = sin(q[1])\nend\n\npode = PODE(q̇, ṗ, [acos(0.4)], [0.0]);","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"The first two arguments to the PODE constructor are the functions that determine the vector fields of the equations dotq (t) = v(t q(t) p(t)) and dotp (t) = f(t q(t) p(t)). The third and fourth argument determines the initial conditions of q and p, respectively. The functions defining the vector field have to take four arguments, the current time t, the current solution vectors q and p and the output vector v or f.","category":"page"},{"location":"tutorial/tutorial/#Integrators","page":"Tutorial","title":"Integrators","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"We support a number of standard integrators (geometric and non-geometric) like explicit, implicit and partitioned Runge-Kutta methods, splitting methods and general linear methods (planned).","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"In order to instantiate many of the standard integrators, one needs to specify an ODE, a tableau and a timestep, e.g.,","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"int = Integrator(ode, TableauExplicitEuler(), 0.1);","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"In order to run the integrator, the integrate() functions is called, passing an integrator object and the number of time steps to integrate:","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"sol = integrate(ode, int, 250);","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"The integrate function automatically creates an appropriate solution object, that contains the result of the integration.","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"plot(sol.q[1,:], sol.q[2,:], xlab=\"x(t)\", ylab=\"y(t)\", legend=:none)","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Observe that the explicit Euler method is not well suited for integrating this system. The solutions drifts away although it should follow closed orbits.","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"For a Hamiltonian system, defined as a PODE, a different tableau might be more appropriate, for example a symplectic Euler method,","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"int = Integrator(pode, TableauSymplecticEulerA(), 0.1)\nsol = integrate(pode, int, 250);","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Error: UndefVarError: TableauSymplecticEulerA not defined","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"This creates a different integrator, which exploits the partitioned structure of the system. The solution return by the integrate step will also be a different solution, adapted to the partitioned system.","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"plot(sol.q[1,:], sol.p[1,:], xlab=\"q(t)\", ylab=\"p(t)\", legend=:none)","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Error: type SSolutionODE has no field p","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Moreover, this method respects the Hamiltonian structure of the system, resulting in closed orbits following the contours of the system's energy.","category":"page"},{"location":"tutorial/tutorial/#Tableaus","page":"Tutorial","title":"Tableaus","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Many tableaus for Runge-Kutta methods are predefined and can easily be used like outlined above. In particular, this includes the following methods:","category":"page"},{"location":"tutorial/tutorial/#Explicit-Runge-Kutta-Methods","page":"Tutorial","title":"Explicit Runge-Kutta Methods","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Function Order Method\nTableauExplicitEuler 1 Explicit / Forward Euler\nTableauExplicitMidpoint 2 Explicit Midpoint\nTableauHeun2 2 Heun's Method of order two\nTableauHeun3 3 Heun's Method of order three\nTableauRalston2 2 Ralston's Method of order two\nTableauRalston3 3 Ralston's Method of order three\nTableauRunge 2 Runge's Method\nTableauKutta 3 Kutta's Method\nTableauRK416 4 Explicit 4th order Runge-Kutta (1/6 rule)\nTableauRK438 4 Explicit 4th order Runge-Kutta (3/8 rule)","category":"page"},{"location":"tutorial/tutorial/#Diagonally-Implicit-Runge-Kutta-Methods","page":"Tutorial","title":"Diagonally Implicit Runge-Kutta Methods","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Function Order Method\nTableauCrankNicolson 3 Crank-Nicholson Method\nTableauKraaijevangerSpijker 3 Kraaijevanger & Spijker's Method\nTableauQinZhang 3 Qin & Zhang's Method\nTableauCrouzeix 3 Crouzeix's Method","category":"page"},{"location":"tutorial/tutorial/#Fully-Implicit-Runge-Kutta-Methods","page":"Tutorial","title":"Fully Implicit Runge-Kutta Methods","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Function Order Method\nTableauImplicitEuler 1 Implicit / Backward Euler\nTableauImplicitMidpoint 2 Implicit Midpoint\nTableauSRK3 4 Symmetric Runge-Kutta s=3","category":"page"},{"location":"tutorial/tutorial/#Gauß,-Radau-and-Lobatto-Methods","page":"Tutorial","title":"Gauß, Radau and Lobatto Methods","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Function Order Method\nTableauGauss) 2s Gauss-Legendre\nTableauRadauIA 2s-1 Radau-IA\nTableauRadauIB 2s-1 Radau-IB\nTableauRadauIIA 2s-1 Radau-IIA\nTableauRadauIIB 2s-1 Radau-IIB\nTableauLobattoIIIA 2s-2 Lobatto-IIIA\nTableauLobattoIIIB 2s-2 Lobatto-IIIB\nTableauLobattoIIIC 2s-2 Lobatto-IIIC\nTableauLobattoIIIC̄ 2s-2 Lobatto-IIIC̄\nTableauLobattoIIID 2s-2 Lobatto-IIID\nTableauLobattoIIIE 2s-2 Lobatto-IIIE\nTableauLobattoIIIF 2s Lobatto-IIIF\nTableauLobattoIIIG 2s Lobatto-IIIG","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"All of these tableaus are generated on the fly and take the number of stages s as parameter.","category":"page"},{"location":"tutorial/tutorial/#Explicit-Partitioned-Runge-Kutta-Methods","page":"Tutorial","title":"Explicit Partitioned Runge-Kutta Methods","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Function Order Method\nTableauSymplecticEulerA 1 Symplectic Euler A\nTableauSymplecticEulerB 1 Symplectic Euler B\nTableauLobattoIIIAIIIB2 2 Lobatto-IIIA-IIIB\nTableauLobattoIIIBIIIA2 2 Lobatto-IIIB-IIIA","category":"page"},{"location":"tutorial/tutorial/#Custom-Tableaus","page":"Tutorial","title":"Custom Tableaus","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"If required, it is straight-forward to create a custom tableau. The tableau of Heun's method, for example, is defined as follows:","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"a = [[0.0 0.0]\n     [1.0 0.0]]\nb = [0.5, 0.5]\nc = [0.0, 1.0]\no = 2\n\ntab = Tableau(:heun, o, a, b, c)","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Runge-Kutta Tableau heun with 2 stages and order 2:","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"  beginarrayrrr\n    00  00  00 \n    10  10  00 hline\n      05  05 \n  endarray","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Here, o is the order of the method, a are the coefficients, b the weights and c the nodes. For partitioned Runge-Kutta tableaus, TableauEPRK and TableauIPRK can be used for explicit and implicit methods, respecrively. The first parameter of the constructor of each tableau assigns a name to the tableau. Such custom tableaus can be used in exactly the same as standard tableaus, e.g., by","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"int = Integrator(ode, tab, 0.1)\nsol = integrate(ode, int, 10);","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"making it very easy to implement and test new methods.","category":"page"},{"location":"tutorial/tutorial/#Solutions","page":"Tutorial","title":"Solutions","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"In what we have seen so far, the solution was always automatically created by the integrate() function. While this is often convenient, it is sometimes not performant, e.g., when carrying out long-time simulations with intermediate saving of the solution. In such cases, it is better to preallocate a solution object by","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"sol = Solution(ode, 0.1, 10);","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"where the first argument is an equation, the second argument is the time step and the third argument is the number of time steps that will be computed in one integration step. The call to the integrator is then made via","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"integrate!(int, sol)","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"If several integration cycles shall be performed, the reset!() function can be used to copy the solution of the last time step to the initial conditions of the solution,","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"for i in 1:10\n    # integrate!(int, sol)\n    #\n    # save or process solution\n    #\n    # reset!(sol)\nend","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"All solutions have a t field holding the series of time steps that has been computed in addition to several data fields, for example q for an ODE solution, q and p for a PODE solution, qand λ for a DAE solution, and q, p and λ for a PDAE solution.","category":"page"},{"location":"modules/equations/#Equations","page":"Equations","title":"Equations","text":"","category":"section"},{"location":"modules/equations/","page":"Equations","title":"Equations","text":"Modules = [GeometricIntegrators.Equations]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"modules/equations/#GeometricIntegrators.Equations.DAE","page":"Equations","title":"GeometricIntegrators.Equations.DAE","text":"DAE: Differential Algebraic Equation\n\nDefines a differential algebraic initial value problem\n\nbeginaligned\ndotq (t) = v(t q(t)) + u(t q(t) lambda(t))   q(t_0) = q_0  \n0 = phi (t q(t) lambda(t))   lambda(t_0) = lambda_0 \nendaligned\n\nwith vector field v, projection u, algebraic constraint phi=0, initial conditions q_0 and lambda_0, the dynamical variable q taking values in mathbbR^m and the algebraic variable lambda taking values in mathbbR^n.\n\nFields\n\nd: dimension of dynamical variable q and the vector field v\nm: dimension of algebraic variable lambda and the constraint phi\nn: number of initial conditions\nv: function computing the vector field\nu: function computing the projection\nϕ: algebraic constraint\nv̄: function computing an initial guess for the velocity field v (optional)\nh: function computing the Hamiltonian (optional)\nt₀: initial time\nq₀: initial condition for dynamical variable q\nλ₀: initial condition for algebraic variable lambda\n\nThe function v, providing the vector field, takes three arguments, v(t, q, v), the functions u and ϕ, providing the projection and the algebraic constraint take four arguments, u(t, q, λ, u) and ϕ(t, q, λ, ϕ), where t is the current time, q and λ are the current solution vectors, and v, u and ϕ are the vectors which hold the result of evaluating the vector field v, the projection u and the algebraic constraint phi on t, q and λ.\n\nExample\n\n    function v(t, q, v)\n        v[1] = q[1]\n        v[2] = q[2]\n    end\n\n    function u(t, q, λ, u)\n        u[1] = +λ[1]\n        u[2] = -λ[1]\n    end\n\n    function ϕ(t, q, λ, ϕ)\n        ϕ[1] = q[2] - q[1]\n    end\n\n    t₀ = 0.\n    q₀ = [1., 1.]\n    λ₀ = [0.]\n\n    dae = DAE(v, u, ϕ, t₀, q₀, λ₀)\n\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.HDAE","page":"Equations","title":"GeometricIntegrators.Equations.HDAE","text":"HDAE: Hamiltonian Differential Algebraic Equation EXPERIMENTAL\n\nDefines a Hamiltonian differential algebraic initial value problem, that is a canonical Hamiltonian system of equations subject to Dirac constraints,\n\nbeginaligned\ndotq (t) = v(t q(t) p(t)) + u(t q(t) p(t) lambda(t)) + barg(t q(t) p(t) lambda(t) gamma(t))   q(t_0) = q_0  \ndotp (t) = f(t q(t) p(t)) + g(t q(t) p(t) lambda(t)) + barf(t q(t) p(t) lambda(t) gamma(t))   p(t_0) = p_0  \n0 = phi (t q(t) p(t))  \n0 = psi (t q(t) p(t) dotq(t) dotp(t)) \nendaligned\n\nwith vector fields v, u, baru and f, g, barg, primary constraint phi(qp)=0 and secondary constraint psi(qplambda)=0, initial conditions (q_0 p_0), the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d and the algebraic variables (lambda gamma) taking values in mathbbR^n times mathbbR^d.\n\nFields\n\nd: dimension of dynamical variables q and p as well as the vector fields v and f\nm: dimension of algebraic variables lambda and gamma and the constraints phi and psi\nv: function computing the Hamiltonian vector field v\nf: function computing the Hamiltonian vector field f\nu: function computing the primary projection field u\ng: function computing the primary projection field g\nu̅: function computing the secondary projection field baru\ng̅: function computing the secondary projection field barg\nϕ: primary constraints\nψ: secondary constraints\nv̄: function computing an initial guess for the velocity field v` (optional)\nf̄: function computing an initial guess for the force field f (optional)\nh: function computing the Hamiltonian H\nt₀: initial time\nq₀: initial condition for dynamical variable q\np₀: initial condition for dynamical variable p\nλ₀: initial condition for algebraic variable λ\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.HODE","page":"Equations","title":"GeometricIntegrators.Equations.HODE","text":"HODE: Hamiltonian Ordinary Differential Equation EXPERIMENTAL\n\nDefines a Hamiltonian ordinary differential initial value problem, that is a canonical Hamiltonian system of equations,\n\nbeginaligned\ndotq (t) = v(t q(t) p(t))   q(t_0) = q_0  \ndotp (t) = f(t q(t) p(t))   p(t_0) = p_0 \nendaligned\n\nwith vector fields v and f, given by\n\nbeginaligned\nv =   fracpartial Hpartial p  \nf = - fracpartial Hpartial q \nendaligned\n\ninitial conditions (q_0 p_0) and the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d.\n\nFields\n\nd: dimension of dynamical variables q and p as well as the vector fields v and f\nv: function computing the vector field v\nf: function computing the vector field f\nh: function computing the Hamiltonian H\nt₀: initial time\nq₀: initial condition for dynamical variable q\np₀: initial condition for dynamical variable p\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.IDAE","page":"Equations","title":"GeometricIntegrators.Equations.IDAE","text":"IDAE: Implicit Differential Algebraic Equation\n\nDefines a partitioned differential algebraic initial value problem\n\nbeginaligned\ndotq (t) = v(t) + u(t q(t) p(t) lambda(t))   q(t_0) = q_0  \ndotp (t) = f(t q(t) v(t)) + r(t q(t) p(t) lambda(t))   p(t_0) = p_0  \np(t) = p(t q(t) v(t))   \n0 = phi (t q(t) p(t) lambda(t))   lambda(t_0) = lambda_0 \nendaligned\n\nwith vector field f, the momentum defined by p, projection u and r, algebraic constraint phi=0, conditions (q_0 p_0) and lambda_0, the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d and the algebraic variable lambda taking values in mathbbR^n.\n\nFields\n\nd: dimension of dynamical variables q and p as well as the vector fields f and p\nm: dimension of algebraic variable lambda and the constraint phi\nϑ: function determining the momentum\nf: function computing the vector field f\nu: function computing the projection for q\ng: function computing the projection for p\nϕ: algebraic constraint\nv̄: function computing an initial guess for the velocity field v (optional)\nf̄: function computing an initial guess for the force field f (optional)\nh: function computing the Hamiltonian (optional)\nt₀: initial time\nq₀: initial condition for dynamical variable q\np₀: initial condition for dynamical variable p\nλ₀: initial condition for algebraic variable lambda\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.IODE","page":"Equations","title":"GeometricIntegrators.Equations.IODE","text":"IODE: Implicit Ordinary Differential Equation\n\nDefines an implicit initial value problem\n\nbeginaligned\ndotq (t) = v(t)  \nq(t_0) = q_0  \ndotp (t) = f(t q(t) v(t))  \np(t_0) = p_0  \np(t) = ϑ(t q(t) v(t))\nendaligned\n\nwith vector field f, the momentum defined by p, initial conditions (q_0 p_0) and the solution (qp) taking values in mathbbR^d times mathbbR^d. This is a special case of a differential algebraic equation with dynamical variables (qp) and algebraic variable v.\n\nFields\n\nd: dimension of dynamical variables q and p as well as the vector fields f and p\nϑ: function determining the momentum\nf: function computing the vector field\ng: function determining the projection, given by nabla vartheta (q) cdot lambda\nv̄: function computing an initial guess for the velocity field v (optional)\nf̄: function computing an initial guess for the force field f (optional)\nh: function computing the Hamiltonian (optional)\nt₀: initial time (optional)\nq₀: initial condition for q\np₀: initial condition for p\n\nThe functions ϑ and f must have the interface\n\n    function ϑ(t, q, v, p)\n        p[1] = ...\n        p[2] = ...\n        ...\n    end\n\nand\n\n    function f(t, q, v, f)\n        f[1] = ...\n        f[2] = ...\n        ...\n    end\n\nwhere t is the current time, q is the current solution vector, v is the current velocity and f and p are the vectors which hold the result of evaluating the functions f and ϑ on t, q and v. In addition, the functions g, v̄ and f̄ are specified by\n\n    function g(t, q, λ, g)\n        g[1] = ...\n        g[2] = ...\n        ...\n    end\n\n    function v̄(t, q, v)\n        v[1] = ...\n        v[2] = ...\n        ...\n    end\n\n    function f̄(t, q, v, f)\n        f[1] = ...\n        f[2] = ...\n        ...\n    end\n\nThe function g is used in projection methods that enforce p = ϑ(q). The functions v̄ and f̄ are used for initial guesses in nonlinear implicit solvers.\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.ODE","page":"Equations","title":"GeometricIntegrators.Equations.ODE","text":"ODE: Ordinary Differential Equation\n\nDefines an initial value problem\n\ndotq (t) = v(t q(t))  qquad q(t_0) = q_0 \n\nwith vector field v, initial condition q_0 and the solution q taking values in mathbbR^d.\n\nFields\n\nd: dimension of dynamical variable q and the vector field v\nv: function computing the vector field\nh: function computing the Hamiltonian (optional)\nt₀: initial time\nq₀: initial condition\n\nThe function v providing the vector field must have the interface\n\n    function v(t, q, v)\n        v[1] = ...\n        v[2] = ...\n        ...\n    end\n\nwhere t is the current time, q is the current solution vector, and v is the vector which holds the result of evaluating the vector field v on t and q.\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.PDAE","page":"Equations","title":"GeometricIntegrators.Equations.PDAE","text":"PDAE: Partitioned Differential Algebraic Equation\n\nDefines a partitioned differential algebraic initial value problem\n\nbeginaligned\ndotq (t) = v(t q(t) p(t)) + u(t q(t) p(t) lambda(t))   q(t_0) = q_0  \ndotp (t) = f(t q(t) p(t)) + r(t q(t) p(t) lambda(t))   p(t_0) = p_0  \n0 = phi (t q(t) p(t) lambda(t))   lambda(t_0) = lambda_0 \nendaligned\n\nwith vector fields v and f, projection u and r, algebraic constraint phi=0, conditions (q_0 p_0) and lambda_0, the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d and the algebraic variable lambda taking values in mathbbR^n.\n\nFields\n\nd: dimension of dynamical variables q and p as well as the vector fields f and p\nm: dimension of algebraic variable lambda and the constraint phi\nv: function computing the vector field v\nf: function computing the vector field f\nu: function computing the projection for q\ng: function computing the projection for p\nϕ: algebraic constraint\nv̄: function computing an initial guess for the velocity field v (optional)\nf̄: function computing an initial guess for the force field f (optional)\nh: function computing the Hamiltonian (optional)\nt₀: initial time\nq₀: initial condition for dynamical variable q\np₀: initial condition for dynamical variable p\nλ₀: initial condition for algebraic variable lambda\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.PODE","page":"Equations","title":"GeometricIntegrators.Equations.PODE","text":"PODE: Partitioned Ordinary Differential Equation\n\nDefines a partitioned initial value problem\n\nbeginaligned\ndotq (t) = v(t q(t) p(t))  \nq(t_0) = q_0  \ndotp (t) = f(t q(t) p(t))  \np(t_0) = p_0 \nendaligned\n\nwith vector fields v and f, initial conditions (q_0 p_0) and the solution (qp) taking values in mathbbR^d times mathbbR^d.\n\nFields\n\nd: dimension of dynamical variables q and p as well as the vector fields v and f\nv: function computing the vector field v\nf: function computing the vector field f\nh: function computing the Hamiltonian (optional)\nt₀: initial time\nq₀: initial condition for q\np₀: initial condition for p\n\nThe functions v and f must have the interface\n\n    function v(t, q, p, v)\n        v[1] = ...\n        v[2] = ...\n        ...\n    end\n\nand\n\n    function f(t, q, p, f)\n        f[1] = ...\n        f[2] = ...\n        ...\n    end\n\nwhere t is the current time, q and p are the current solution vectors and v and f are the vectors which hold the result of evaluating the vector fields v and f on t, q and p.\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.PSDE","page":"Equations","title":"GeometricIntegrators.Equations.PSDE","text":"PSDE: Stratonovich Partitioned Stochastic Differential Equation\n\nDefines a partitioned stochastic differential initial value problem\n\nbeginaligned\ndq (t) = v(t q(t))  dt + B(t q(t)) circ dW   q(t_0) = q_0  \ndp (t) = f(t q(t))  dt + G(t q(t)) circ dW   p(t_0) = p_0\nendaligned\n\nwith the drift vector fields v and f, diffusion matrices B and G, initial conditions q_0 and p_0, the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d, and the m-dimensional Wiener process W\n\nFields\n\nd:  dimension of dynamical variable q and the vector field v\nm:  dimension of the Wiener process\nns: number of sample paths\nv:  function computing the drift vector field for the position variable q\nf:  function computing the drift vector field for the momentum variable p\nB:  function computing the d x m diffusion matrix for the position variable q\nG:  function computing the d x m diffusion matrix for the momentum variable p\nt₀: initial time\nq₀: initial condition for dynamical variable q (may be a random variable itself)\np₀: initial condition for dynamical variable p (may be a random variable itself)\n\nThe functions v, f, B and G, providing the drift vector fields and diffusion matrices, take four arguments, v(t, q, p, v), f(t, q, p, f), B(t, q, p,  B) and G(t, q, p, G), where t is the current time, (q, p) is the current solution vector, and v, f, B and G are the variables which hold the result of evaluating the vector fields v, f and the matrices B, G on t and (q,p).\n\nExample\n\n    function v(λ, t, q, v)\n        v[1] = λ*q[1]\n        v[2] = λ*q[2]\n    end\n\n    function B(μ, t, q, B)\n        B[1] = μ*q[1]\n        B[2] = μ*q[2]\n    end\n\n    t₀ = 0.\n    q₀ = [1., 1.]\n    λ  = 2.\n    μ  = 1.\n\n    v_sde = (t, q, v) -> v(λ, t, q, v)\n    B_sde = (t, q, B) -> B(μ, t, q, B)\n\n    sde = SDE(v_sde, B_sde, t₀, q₀)\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.SDE","page":"Equations","title":"GeometricIntegrators.Equations.SDE","text":"SDE: Stratonovich Stochastic Differential Equation\n\nDefines a stochastic differential initial value problem\n\nbeginaligned\ndq (t) = v(t q(t))  dt + B(t q(t)) circ dW   q(t_0) = q_0 \nendaligned\n\nwith drift vector field v, diffusion matrix B, initial conditions q_0, the dynamical variable q taking values in mathbbR^d, and the m-dimensional Wiener process W\n\nFields\n\nd:  dimension of dynamical variable q and the vector field v\nm:  dimension of the Wiener process\nns: number of sample paths\nv:  function computing the deterministic vector field\nB:  function computing the d x m diffusion matrix\nt₀: initial time\nq₀: initial condition for dynamical variable q (may be a random variable itself)\n\nParameters\n\nN: dimension of nitial condition array: N=1 - single, N=2 - multiple\n\nThe functions v and B, providing the drift vector field and diffusion matrix, v(t, q, v) and B(t, q, B, col=0), where t is the current time, q is the current solution vector, and v and B are the variables which hold the result of evaluating the vector field v and the matrix B on t and q (if col==0), or the column col of the matrix B (if col>0).\n\nExample\n\n    function v(t, q, v, p)\n        λ = p[:λ]\n        v[1] = λ*q[1]\n        v[2] = λ*q[2]\n    end\n\n    function B(t, q, B, p, col=0)\n        μ = p[:μ]\n        if col==0 #whole matrix\n            B[1,1] = μ*q[1]\n            B[2,1] = μ*q[2]\n        elseif col==1\n            #just first column\n        end\n    end\n\n    t₀ = 0.\n    q₀ = [1., 1.]\n    λ  = 2.\n    μ  = 1.\n    p = (λ=λ, μ=μ)\n\n    sde = SDE(v, B, t₀, q₀; parameters=p)\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.SODE","page":"Equations","title":"GeometricIntegrators.Equations.SODE","text":"SODE: Split Ordinary Differential Equation\n\nDefines an initial value problem\n\ndotq (t) = v(t q(t))  qquad q(t_0) = q_0 \n\nwith vector field v, initial condition q_0 and the solution q taking values in mathbbR^d. Here, the vector field v is given as a sum of vector fields\n\nv (t) = v_1 (t) +  + v_r (t) \n\nFields\n\nd: dimension of dynamical variable q and the vector field v\nv: tuple of functions computing the vector field\nq: tuple of functions computing the solution\nt₀: initial time\nq₀: initial condition\n\nThe functions v_i providing the vector field must have the interface\n\n    function v_i(t, q, v)\n        v[1] = ...\n        v[2] = ...\n        ...\n    end\n\nand the functions q_i providing the solutions must have the interface\n\n    function q_i(t, q₀, q₁, h)\n        q₁[1] = q₀[1] + ...\n        q₁[2] = q₀[2] + ...\n        ...\n    end\n\nwhere t is the current time, q₀ is the current solution vector, q₁ is the new solution vector which holds the result of computing one substep with the vector field v_i on t and q₀, and h is the (sub-)timestep to compute the update for.\n\nThe fact that the function v returns the solution and not just the vector field for each substep increases the flexibility for the use of splitting methods, e.g., it allows to use another integrator for solving substeps.\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.SPDAE","page":"Equations","title":"GeometricIntegrators.Equations.SPDAE","text":"SPDAE: Split Partitioned Differential Algebraic Equation EXPERIMENTAL\n\nDefines a split differential algebraic initial value problem, that is a canonical Hamiltonian system of equations subject to Dirac constraints,\n\nbeginaligned\ndotq (t) = v_1(t q(t) p(t)) + v_2(t q(t) p(t) lambda(t)) + v_3(t q(t) p(t) lambda(t) gamma(t))   q(t_0) = q_0  \ndotp (t) = f_1(t q(t) p(t)) + f_2(t q(t) p(t) lambda(t)) + f_3(t q(t) p(t) lambda(t) gamma(t))   p(t_0) = p_0  \n0 = phi (t q(t) p(t))  \n0 = psi (t q(t) p(t) dotq(t) dotp(t)) \nendaligned\n\nwith vector fields v_i and f_i for i = 1  3, primary constraint phi(qp)=0 and secondary constraint psi(qplambda)=0, initial conditions (q_0 p_0), the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d and the algebraic variables (lambda gamma) taking values in mathbbR^n times mathbbR^d.\n\nFields\n\nd: dimension of dynamical variables q and p as well as the vector fields v and f\nm: dimension of algebraic variables lambda and gamma and the constraints phi and psi\nn: number of initial conditions\nv: tuple of functions computing the vector fields v_i, i = 1  3\nf: tuple of functions computing the vector fields f_i, i = 1  3\nϕ: primary constraints\nψ: secondary constraints\nt₀: initial time\nq₀: initial condition for dynamical variable q\np₀: initial condition for dynamical variable p\nλ₀: initial condition for algebraic variable λ\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.SPSDE","page":"Equations","title":"GeometricIntegrators.Equations.SPSDE","text":"SPSDE: Stratonovich Split Partitioned Stochastic Differential Equation\n\nDefines a partitioned stochastic differential initial value problem\n\nbeginaligned\ndq (t) =   v(t q(t))  dt + B(t q(t)) circ dW   q(t_0) = q_0  \ndp (t) =  f_1(t q(t)) + f_2(t q(t))   dt +  G_1(t q(t)) + G_2(t q(t))  circ dW   p(t_0) = p_0 \nendaligned\n\nwith the drift vector fields v and f_i, diffusion matrices B and G_i, initial conditions q_0 and p_0, the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d, and the m-dimensional Wiener process W\n\nFields\n\nd:  dimension of dynamical variable q and the vector fields vi\nm:  dimension of the Wiener process\nni: number of initial conditions\nns: number of sample paths\nv :  function computing the drift vector field for the position variable q\nf1:  function computing the drift vector field for the momentum variable p\nf2:  function computing the drift vector field for the momentum variable p\nB :  function computing the d x m diffusion matrix for the position variable q\nG1:  function computing the d x m diffusion matrix for the momentum variable p\nG2:  function computing the d x m diffusion matrix for the momentum variable p\nt₀: initial time\nq₀: initial condition for dynamical variable q (may be a random variable itself)\np₀: initial condition for dynamical variable p (may be a random variable itself)\n\nThe functions v, f, B and G, providing the drift vector fields and diffusion matrices, take four arguments, v(t, q, p, v), f(t, q, p, f), B(t, q, p,  B) and G(t, q, p, G), where t is the current time, (q, p) is the current solution vector, and v, f, B and G are the variables which hold the result of evaluating the vector fields v, f and the matrices B, G on t and (q,p).\n\nExample\n\n    function v(λ, t, q, v)\n        v[1] = λ*q[1]\n        v[2] = λ*q[2]\n    end\n\n    function B(μ, t, q, B)\n        B[1] = μ*q[1]\n        B[2] = μ*q[2]\n    end\n\n    t₀ = 0.\n    q₀ = [1., 1.]\n    λ  = 2.\n    μ  = 1.\n\n    v_sde = (t, q, v) -> v(λ, t, q, v)\n    B_sde = (t, q, B) -> B(μ, t, q, B)\n\n    sde = SDE(v_sde, B_sde, t₀, q₀)\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.VDAE","page":"Equations","title":"GeometricIntegrators.Equations.VDAE","text":"VDAE: Variational Differential Algebraic Equation EXPERIMENTAL\n\nDefines an implicit initial value problem\n\nbeginaligned\ndotq (t) = v(t) + lambda(t) \nq(t_0) = q_0  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) lambda(t)) + barg (t q(t) mu(t))  \np(t_0) = p_0  \np(t) = ϑ(t q(t) v(t))  \n0 = phi (t q(t) p(t))  \n0 = psi (t q(t) p(t) dotq(t) dotp(t)) \nendaligned\n\nwith vector field f, the momentum defined by p, initial conditions (q_0 p_0) and the solution (qp) taking values in mathbbR^d times mathbbR^d and the algebraic variables (v lambda mu) taking values in mathbbR^d times mathbbR^d times mathbbR^m. This is a special case of a differential algebraic equation with dynamical variables (qp) and algebraic variables v, lambda and mu.\n\nFields\n\nd: dimension of dynamical variables q and p as well as the vector fields f and p\nϑ: function determining the momentum\nf: function computing the vector field\ng: function determining the primary projection, usually given by nabla vartheta (q) cdot lambda\ng̅: function determining the secondary projection, usually given by lambda cdot nabla vartheta (q)\nϕ: primary constraints, usually given by p - vartheta (q)\nψ: secondary constraints, usually given by dotp - dotq cdot nabla vartheta (q)\nv̄: function computing an initial guess for the velocity field v (optional)\nf̄: function computing an initial guess for the force field f (optional)\nh: function computing the Hamiltonian (optional)\nΩ: symplectic matrix (optional)\n∇H: gradient of the Hamiltonian (optional)\nt₀: initial time (optional)\nq₀: initial condition for q\np₀: initial condition for p\nλ₀: initial condition for λ (optional)\nμ₀: initial condition for μ (optional)\n\nThe functions ϑ and f must have the interface\n\n    function ϑ(t, q, v, p)\n        p[1] = ...\n        p[2] = ...\n        ...\n    end\n\nand\n\n    function f(t, q, v, f)\n        f[1] = ...\n        f[2] = ...\n        ...\n    end\n\nwhere t is the current time, q is the current solution vector, v is the current velocity and f and p are the vectors which hold the result of evaluating the functions f and ϑ on t, q and v. The funtions g, v̄ and f̄ are specified by\n\n    function g(t, q, λ, g)\n        g[1] = ...\n        g[2] = ...\n        ...\n    end\n\n    function v̄(t, q, v)\n        v[1] = ...\n        v[2] = ...\n        ...\n    end\n\n    function f̄(t, q, v, f)\n        f[1] = ...\n        f[2] = ...\n        ...\n    end\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.VODE","page":"Equations","title":"GeometricIntegrators.Equations.VODE","text":"VODE: Variational Ordinary Differential Equation EXPERIMENTAL\n\nDefines an implicit initial value problem\n\nbeginaligned\ndotq (t) = v(t)  \nq(t_0) = q_0  \ndotp (t) = f(t q(t) v(t))  \np(t_0) = p_0  \np(t) = ϑ(t q(t) v(t))\nendaligned\n\nwith vector field f, the momentum defined by p, initial conditions (q_0 p_0) and the solution (qp) taking values in mathbbR^d times mathbbR^d. This is a special case of a differential algebraic equation with dynamical variables (qp) and algebraic variable v.\n\nFields\n\nd: dimension of dynamical variables q and p as well as the vector fields f and p\nϑ: function determining the momentum\nf: function computing the vector field\ng: function determining the projection, given by nabla vartheta (q) cdot lambda\nv̄: function computing an initial guess for the velocity field v (optional)\nf̄: function computing an initial guess for the force field f (optional)\nh: function computing the Hamiltonian (optional)\nΩ: symplectic matrix (optional)\n∇H: gradient of the Hamiltonian (optional)\nt₀: initial time (optional)\nq₀: initial condition for q\np₀: initial condition for p\nλ₀: initial condition for λ (optional)\n\nThe functions ϑ and f must have the interface\n\n    function ϑ(t, q, v, p)\n        p[1] = ...\n        p[2] = ...\n        ...\n    end\n\nand\n\n    function f(t, q, v, f)\n        f[1] = ...\n        f[2] = ...\n        ...\n    end\n\nwhere t is the current time, q is the current solution vector, v is the current velocity and f and p are the vectors which hold the result of evaluating the functions f and ϑ on t, q and v. The funtions g and v are specified by\n\n    function g(t, q, λ, g)\n        g[1] = ...\n        g[2] = ...\n        ...\n    end\n\nand\n\n    function v(t, q, p, v)\n        v[1] = ...\n        v[2] = ...\n        ...\n    end\n\n\n\n\n\n","category":"type"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"CurrentModule = GeometricIntegrators.Integrators.VPRK","category":"page"},{"location":"integrators/vprk/#Variational-Partitioned-Runge-Kutta-Integrators","page":"VPRK","title":"Variational Partitioned Runge-Kutta Integrators","text":"","category":"section"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Variational partitioned Runge-Kutta methods solve Lagranian systems in implicit form, i.e.,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginaligned\np       = dfracpartial Lpartial dotq (q dotq)  \ndotp = dfracpartial Lpartial q       (q dotq)  \nendaligned","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"by the following scheme,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginaligned\nP_ni = dfracpartial Lpartial dotq (Q_ni V_ni)  \nF_ni = dfracpartial Lpartial q       (Q_ni V_ni)  \nQ_ni = q_n + h sum limits_j=1^s a_ij        V_nj  \nP_ni = p_n + h sum limits_j=1^s bara_ij  F_nj  \nq_n+1 = q_n + h sum limits_i=1^s b_i         V_ni  \np_n+1 = p_n + h sum limits_i=1^s barb_i   F_ni \nendaligned","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Here, s denotes the number of internal stages, a_ij and bara_ij are the coefficients of the Runge-Kutta method and b_i and barb_i the corresponding weights. If the coefficients satisfy the symplecticity conditions,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginaligned\nb_i bara_ij + barb_j a_ji = b_i barb_j \n textand \nbarb_i = b_i \nendaligned","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"these methods correspond to the position-momentum form of the discrete Lagrangian [Matthew Marsden Jerrold E. AND West (2001)]","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"L_d (q_n q_n+1) = h sum limits_i=1^s b_i  L big( Q_ni V_ni big) ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"While these integrators show favourable properties for systems with regular Lagrangian, they are usually not applicable for degenerate Lagrangian systems, in particular those with Lagrangians of the form L (q dotq) = vartheta(q) cdot dotq - H(q). While variational integrators are still applicable in the case of vartheta being a linear function of q, they are often found to be unstable when vartheta is a nonlinear function of q as is the case with Lotka-Volterra systems, guiding centre dynamics and various nonlinear oscillators. To mitigate this problem, projection methods have been developed, which when applied to variational integrators provide long-time stable integrators for general degenerate Lagrangian systems that maintain conservation of energy and momenta [Michael Kraus  (2017)].","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"GeometricIntegrators.jl provides the following VPRK methods (some are still experimental):","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Integrator Description\nIntegratorVPRK Variational Partitioned Runge-Kutta (VPRK) integrator without projection\nIntegratorVPRKpStandard VPRK integrator with standard projection\nIntegratorVPRKpSymmetric VPRK integrator with symmetric projection\nIntegratorVPRKpMidpoint VPRK integrator with midpoint projection\nIntegratorVPRKpVariational VPRK integrator with variational projection\nIntegratorVPRKpSecondary VPRK integrator with projection on secondary constraint\nIntegratorVPRKpInternal Gauss-Legendre VPRK integrator with projection on internal stages of Runge-Kutta method\nIntegratorVPRKpTableau Gauss-Legendre VPRK integrator with projection in tableau of Runge-Kutta method","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"For testing purposes IntegratorVPRKpStandard provides some additional constructors (these methods are generally unstable):","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Integrator Description\nIntegratorVPRKpVariationalQ VPRK integrator with variational projection on (q_n p_n+1)\nIntegratorVPRKpVariationalP VPRK integrator with variational projection on (p_n q_n+1)\nIntegratorVPRKpSymplectic VPRK integrator with symplectic projection","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"All of the above integrators are applied to an IODE.","category":"page"},{"location":"tableaus/spark/#SPARK-Tableaus","page":"SPARK Methods","title":"SPARK Tableaus","text":"","category":"section"},{"location":"tableaus/spark/","page":"SPARK Methods","title":"SPARK Methods","text":"Modules = [GeometricIntegrators.Tableaus]\nPages   = [\"tableaus/coefficients_glrk.jl\",\n           \"tableaus/coefficients_lob.jl\",\n           \"tableaus/tableaus_hpark.jl\",\n           \"tableaus/tableaus_hspark_primary.jl\",\n           \"tableaus/tableaus_hspark_secondary.jl\",\n           \"tableaus/tableaus_slrk.jl\",\n           \"tableaus/tableaus_spark.jl\",\n           \"tableaus/tableaus_vpark.jl\",\n           \"tableaus/tableaus_vspark_primary.jl\",\n           \"tableaus/tableaus_vspark_secondary.jl\"]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.get_lobatto_glrk_coefficients","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.get_lobatto_glrk_coefficients","text":"The projective Lobatto-GLRK coefficients are implicitly given by\n\nsum limits_j=1^s a_ij c_j^k-1 = fracbarc_i^kk  qquad i = 1      sigma   k = 1      s \n\nwhere c are Gauß-Legendre nodes with s stages and barc are Gauß-Lobatto nodes with sigma stages.\n\n\n\n\n\n","category":"function"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauHPARKGLRK-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauHPARKGLRK","text":"Tableau for Gauss-Legendre HPARK method with s stages.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauHPARKLobattoIIIAIIIB-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauHPARKLobattoIIIAIIIB","text":"SPARK tableau for Gauss-Lobatto IIIA-IIIB HPARK method with s stages.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauHPARKLobattoIIIBIIIA-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauHPARKLobattoIIIBIIIA","text":"SPARK tableau for Gauss-Lobatto IIIB-IIIA  method with s stages.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauHSPARKGLRKpSymmetric-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauHSPARKGLRKpSymmetric","text":"Tableau for Gauss-Legendre method with s stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauHSPARKLobattoIIIAIIIBpSymmetric-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauHSPARKLobattoIIIAIIIBpSymmetric","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with s stages and symmetric projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauHSPARKLobattoIIIBIIIApSymmetric-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauHSPARKLobattoIIIBIIIApSymmetric","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages and symmetric projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauSPARKGLRK-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauSPARKGLRK","text":"SPARK tableau for Gauss-Legendre Runge-Kutta method with s stages.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauSPARKGLRKLobattoIIIAIIIB","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauSPARKGLRKLobattoIIIAIIIB","text":"SPARK tableau for Gauss-Legendre/Gauss-Lobatto-IIIA-IIIB methods.\n\n\n\n\n\n","category":"function"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauSPARKGLRKLobattoIIIBIIIA","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauSPARKGLRKLobattoIIIBIIIA","text":"SPARK tableau for Gauss-Legendre/Gauss-Lobatto-IIIB-IIIA methods.\n\n\n\n\n\n","category":"function"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauSPARKGLVPRK-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauSPARKGLVPRK","text":"Tableau for Variational Gauss-Legendre method with s stages.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauSPARKLobABC-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauSPARKLobABC","text":"Tableau for Gauss-Lobatto IIIA-IIIB-IIIC method with s stages.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauSPARKLobABD-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauSPARKLobABD","text":"Tableau for Gauss-Lobatto IIIA-IIIB-IIID method with s stages.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauSPARKLobatto-Tuple{Any,Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauSPARKLobatto","text":"SPARK tableau for Gauss-Lobatto methods.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauSPARKLobattoIIIAIIIB-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauSPARKLobattoIIIAIIIB","text":"SPARK tableau for Gauss-Lobatto IIIA-IIIB method with s stages.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauSPARKLobattoIIIBIIIA-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauSPARKLobattoIIIBIIIA","text":"SPARK tableau for Gauss-Lobatto IIIB-IIIA method with s stages.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauSPARKVPRK-Union{Tuple{T}, Tuple{Any,Tableau{T},Tableau{T}}, Tuple{Any,Tableau{T},Tableau{T},Any}} where T","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauSPARKVPRK","text":"SPARK Tableau for Variational Partitioned Runge-Kutta Methods.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauGausspSymplectic-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauGausspSymplectic","text":"Tableau for Gauss-Legendre method with s stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauLobattoIIIAIIIBpSymplectic-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauLobattoIIIAIIIBpSymplectic","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with s stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauLobattoIIIBIIIApSymplectic-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauLobattoIIIBIIIApSymplectic","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKGLRKpInternal-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKGLRKpInternal","text":"Tableau for Gauss-Legendre method with s stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKGLRKpLobattoIIIAIIIB-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKGLRKpLobattoIIIAIIIB","text":"Tableau for Gauss-Legendre method with s stages and Lobatto-IIIA-IIIB projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKGLRKpLobattoIIIBIIIA-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKGLRKpLobattoIIIBIIIA","text":"Tableau for Gauss-Legendre method with s stages and Lobatto-IIIB-IIIA projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKGLRKpMidpoint-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKGLRKpMidpoint","text":"Tableau for Gauss-Legendre method with s stages and midpoint projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKGLRKpModifiedInternal-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKGLRKpModifiedInternal","text":"Tableau for Gauss-Legendre method with s stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKGLRKpModifiedLobattoIIIAIIIB-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKGLRKpModifiedLobattoIIIAIIIB","text":"Tableau for Gauss-Legendre method with s stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKGLRKpModifiedLobattoIIIBIIIA-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKGLRKpModifiedLobattoIIIBIIIA","text":"Tableau for Gauss-Legendre method with s stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKGLRKpModifiedMidpoint-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKGLRKpModifiedMidpoint","text":"Tableau for Gauss-Legendre method with s stages and midpoint projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKGLRKpSymmetric-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKGLRKpSymmetric","text":"Tableau for Gauss-Legendre method with s stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKInternalProjection-Union{Tuple{T}, Tuple{Any,Tableau{T},Tableau{T}}, Tuple{Any,Tableau{T},Tableau{T},Any}} where T","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKInternalProjection","text":"Consider a symplectic pair of tableaus (a^1 b^1 c^1) and (a^3 b^3 c^3), i.e., satsifying b^1_i b^3_j = b^1_i a^3_ij + b^3_j a^1_ji, with an arbitrary number of stages s. Use the same tableaus for tildea^1 and tildea^3, so that tildes = s, as well as\n\nbeginaligned\nbeginarrayccc\n tfrac12 b^1 \n vdots \n tfrac12 b^1 \nhline\na^2  \nendarray\n\nbeginarrayccc\n tfrac12 b^3 \n vdots \n tfrac12 b^3 \nhline\na^4  \nendarray\n\nbeginarrayccc\n tfrac12 b^1 \nc^1  vdots \n tfrac12 b^1 \nhline\ntildea^2  tfrac12 (1 + R(infty))  b^1 \nendarray\n\nbeginarrayccc\n tfrac12 b^3 \nc^3  vdots \n tfrac12 b^3 \nhline\ntildea^4  tfrac12 (1 + R(infty))  b^3 \nendarray\nendaligned\n\nSet omega = 0  0 1 and\n\ndelta_ij = begincases\n+1  j = i  \n-1  j = tildes  \n 0  textelse \nendcases\n\nso that Lambda_1 = Lambda_2 =  = Lambda_tildes.\n\nThis methods is constructed to satisfy the constraint on the projective stages, phi(tildeQ_ni tildeP_ni) = 0 for i = 1    tildes. Note, however, that it violates the symplecticity conditions b^1_i b^4_j = b^1_i a^4_ij + b^4_j tildea^1_ji and b^2_i b^3_j = b^2_i tildea^3_ij + b^3_j a^2_ji.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIAIIIBProjection-Union{Tuple{T}, Tuple{Any,Tableau{T},Tableau{T}}, Tuple{Any,Tableau{T},Tableau{T},Any}} where T","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIAIIIBProjection","text":"Consider a symplectic pair of tableaus (a^1 b^1 c^1) and (a^3 b^3 c^3), i.e., satsifying b^1_i b^3_j = b^1_i a^3_ij + b^3_j a^1_ji, with an arbitrary number of stages s. For the projection, choose the Lobatto-IIIA and IIIB tableaus with tildes = 2 stages for (tildea^4 b^4) and (tildea^2 b^2), respectively, and choose tildea^1 and tildea^3 such that the projective stages correspond to the initial condition and the solution, i.e.,\n\nbeginaligned\nbeginarrayccc\n0  0 \n1  b^1 \nhline\ntildea^1  \nendarray\n\nbeginarrayccc\n0  tfrac12  0 \n1  tfrac12  0 \nhline\ntildea^2  \nendarray\n\nbeginarrayccc\n0  0 \n1  b^3 \nhline\ntildea^3  \nendarray\n\nbeginarrayccc\n0  0  0 \n1  tfrac12  tfrac12 \nhline\ntildea^4  \nendarray\nendaligned\n\nand compute a^2 and a^4 by the symplecticity conditions, that is a^2_ij = b^2_j ( b^3_i - tildea^3_ji )  b^3_i and a^4_ij = b^4_j ( b^1_i - tildea^1_ji)  b^1_i. Finally choose omega = 0 0 1 and delta = -1 R_infty, implying that rho = 1. By construction, this method satisfies all symplecticity conditions, but the constraint on the projection stages, phi(tildeQ_ni tildeP_ni) = 0 for i = 1    tildes, is not satisfied exactly, but only approximately, although with bounded error.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIAIIIBpLobattoIIIAIIIB-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIAIIIBpLobattoIIIAIIIB","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with s stages and Lobatto-IIIA-IIIB projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIAIIIBpLobattoIIIBIIIA-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIAIIIBpLobattoIIIBIIIA","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with s stages and Lobatto-IIIB-IIIA projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIAIIIBpMidpoint-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIAIIIBpMidpoint","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with s stages and midpoint projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIAIIIBpModifiedLobattoIIIAIIIB-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIAIIIBpModifiedLobattoIIIAIIIB","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with s stages and Lobatto-IIIA-IIIB projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIAIIIBpModifiedLobattoIIIBIIIA-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIAIIIBpModifiedLobattoIIIBIIIA","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with s stages and Lobatto-IIIB-IIIA projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIAIIIBpModifiedMidpoint-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIAIIIBpModifiedMidpoint","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with s stages and midpoint projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIAIIIBpSymmetric-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIAIIIBpSymmetric","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with s stages and symmetric projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIBIIIAProjection-Union{Tuple{T}, Tuple{Any,Tableau{T},Tableau{T}}, Tuple{Any,Tableau{T},Tableau{T},Any}} where T","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIBIIIAProjection","text":"This methods is the same as TableauVSPARKLobattoIIIAIIIBProjection, except for using Lobatto-IIIA and IIIB tableaus with tildes = 2 stages for (tildea^2 b^2), and (tildea^4 b^4) respectively, instead of the other way around.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIBIIIApLobattoIIIAIIIB-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIBIIIApLobattoIIIAIIIB","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages and Lobatto-IIIA-IIIB projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIBIIIApLobattoIIIBIIIA-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIBIIIApLobattoIIIBIIIA","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages and Lobatto-IIIB-IIIA projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIBIIIApMidpoint-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIBIIIApMidpoint","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages and midpoint projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIBIIIApModifiedLobattoIIIAIIIB-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIBIIIApModifiedLobattoIIIAIIIB","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages and Lobatto-IIIA-IIIB projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIBIIIApModifiedLobattoIIIBIIIA-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIBIIIApModifiedLobattoIIIBIIIA","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages and Lobatto-IIIB-IIIA projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIBIIIApModifiedMidpoint-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIBIIIApModifiedMidpoint","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages and midpoint projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIBIIIApSymmetric-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIBIIIApSymmetric","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages and symmetric projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKMidpointProjection-Union{Tuple{T}, Tuple{Any,Tableau{T},Tableau{T}}, Tuple{Any,Tableau{T},Tableau{T},Any}} where T","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKMidpointProjection","text":"Consider a symplectic pair of tableaus (a^1 b^1 c^1) and (a^3 b^3 c^3), i.e., satsifying b^1_i b^3_j = b^1_i a^3_ij + b^3_j a^1_ji, with an arbitrary number of stages s. For the projection, choose the tableau with tildes = 1 and rho = 0, such that tildeQ_n1 = tfrac12 ( q_n + q_n+1), tildeP_n1 = tfrac12 ( p_n + p_n+1), i.e.,\n\nbeginaligned\nbeginarrayccc\n tfrac12 \n vdots \n tfrac12 \nhline\na^2  \nendarray\n\nbeginarrayccc\n tfrac12 \n vdots \n tfrac12 \nhline\na^4  \nendarray\n\nbeginarrayccc\ntfrac12  tfrac12 \nhline\ntildea^2  tfrac12 (1 + R(infty))\nendarray\n\nbeginarrayccc\ntfrac12  tfrac12 \nhline\ntildea^4  tfrac12 (1 + R(infty))\nendarray\nendaligned\n\nThe coefficients tildea^1 and tildea^3 are determined by the symplecticity conditions, specifically a^4_ij = b^4_j ( b^1_i - tildea^1_ji)  b^1_i and a^2_ij = b^2_j ( b^3_i - tildea^3_ji )  b^3_i, and omega = 0 1.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKModifiedInternalProjection","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKModifiedInternalProjection","text":"Consider a symplectic pair of tableaus (a^1 b^1 c^1) and (a^3 b^3 c^3), i.e., satsifying b^1_i b^3_j = b^1_i a^3_ij + b^3_j a^1_ji, with an arbitrary number of stages s, and set\n\nbeginaligned\nbeginarrayccc\n tfrac12 b^1 \n vdots \n tfrac12 b^1 \nhline\na^2  \nendarray\n\nbeginarrayccc\n tfrac12 b^4 \n vdots \n tfrac12 b^4 \nhline\na^4  \nendarray\n\nbeginarrayccc\n tfrac12 b^1 \nc^1  vdots \n tfrac12 b^1 \nhline\ntildea^2  tfrac12 (1 + R(infty))  b^1 \nendarray\n\nbeginarrayccc\n tfrac12 b^3 \nc^3  vdots \n tfrac12 b^3 \nhline\ntildea^4  tfrac12 (1 + R(infty))  b^3 \nendarray\nendaligned\n\nNote that by this definition tildes = s. The coefficients tildea^1 and tildea^3 are determined by the (modified) symplecticity conditions, specifically a^4_ij = b^3_j ( b^1_i - tildea^1_ji)  b^1_i and a^2_ij = b^1_j ( b^3_i - tildea^3_ji )  b^3_i, where b^2 has been replaced with b^1 and b^4 with b^3, respectively. Set omega = 0  0 1 and\n\ndelta_ij = begincases\n+1  j = i  \n-1  j = tildes  \n 0  textelse \nendcases\n\nso that Lambda_1 = Lambda_2 =  = Lambda_tildes.\n\nNote that this method satisfies the symplecticity conditions b^1_i b^4_j = b^1_i a^4_ij + b^4_j tildea^1_ji and b^2_i b^3_j = b^2_i tildea^3_ij + b^3_j a^2_ji only if R(infty) = 1 due to the definitions of b^2 and b^4. Moreover, it does usually not satisfy the constraint on the projective stages, phi(tildeQ_ni tildeP_ni) = 0 for i = 1    tildes, exactly, but only approximately with bounded error, thus implying a residual in the symplecticity equation even if R(infty) = 1.\n\n\n\n\n\n","category":"function"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKModifiedLobattoIIIAIIIBProjection-Union{Tuple{T}, Tuple{Any,Tableau{T},Tableau{T}}, Tuple{Any,Tableau{T},Tableau{T},Any}} where T","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKModifiedLobattoIIIAIIIBProjection","text":"Consider a symplectic pair of tableaus (a^1 b^1 c^1) and (a^3 b^3 c^3), i.e., satsifying b^1_i b^3_j = b^1_i a^3_ij + b^3_j a^1_ji, with an arbitrary number of stages s. For the projection, choose the Lobatto-IIIA and IIIB tableaus with tildes = 2 stages for (tildea^4 b^4) and (tildea^2 b^2), respectively.\n\nThe coefficients tildea^1 and tildea^3 are determined by the relations\n\nbeginaligned\nsum limits_j=1^s tildea^1_ij (c_j^1)^k-1 = frac(c_i^2)^kk  qquad \nsum limits_j=1^s tildea^3_ij (c_j^3)^k-1 = frac(c_i^4)^kk  qquad \ni = 1      tildes  qquad \nk = 1      s \nendaligned\n\nThe coefficients a^2 and a^4 by the symplecticity conditions, that is a^2_ij = b^2_j ( b^3_i - tildea^3_ji )  b^3_i and a^4_ij = b^4_j ( b^1_i - tildea^1_ji)  b^1_i. Finally choose omega = 0 0 1 and delta = -1 R_infty, implying that rho = 1. By construction, this method satisfies all symplecticity conditions, but the constraint on the projection stages, phi(tildeQ_ni tildeP_ni) = 0 for i = 1    tildes, is not satisfied exactly, but only approximately, although with bounded error.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKModifiedLobattoIIIBIIIAProjection-Union{Tuple{T}, Tuple{Any,Tableau{T},Tableau{T}}, Tuple{Any,Tableau{T},Tableau{T},Any}} where T","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKModifiedLobattoIIIBIIIAProjection","text":"This methods is the same as TableauVSPARKModifiedLobattoIIIAIIIBProjection, except for using Lobatto-IIIA and IIIB tableaus with tildes = 2 stages for (tildea^2 b^2), and (tildea^4 b^4) respectively, instead of the other way around.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKModifiedMidpointProjection-Union{Tuple{T}, Tuple{Any,Tableau{T},Tableau{T}}, Tuple{Any,Tableau{T},Tableau{T},Any}} where T","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKModifiedMidpointProjection","text":"Consider a symplectic pair of tableaus (a^1 b^1 c^1) and (a^3 b^3 c^3), i.e., satsifying b^1_i b^3_j = b^1_i a^3_ij + b^3_j a^1_ji, with an arbitrary number of stages s. For the projection, choose the tableau with tildes = 1 and rho = 0, such that tildeQ_n1 = tfrac12 ( q_n + q_n+1), tildeP_n1 = tfrac12 ( p_n + p_n+1), i.e.,\n\nbeginaligned\nbeginarrayccc\ntfrac12  tfrac12 b^1 \nhline\ntildea^1  \nendarray\n\nbeginarrayccc\ntfrac12  tfrac12 \nhline\ntildea^2  tfrac12 ( 1 + R (infty) ) \nendarray\n\nbeginarrayccc\ntfrac12  tfrac12 b^3 \nhline\ntildea^3  \nendarray\n\nbeginarrayccc\ntfrac12  tfrac12 \nhline\ntildea^4  tfrac12 ( 1 + R (infty) ) \nendarray\nendaligned\n\nThe coefficients a^2 and a^4 are determined by the symplecticity conditions, specifically a^4_ij = b^4_j ( b^1_i - tildea^1_ji)  b^1_i and a^2_ij = b^2_j ( b^3_i - tildea^3_ji )  b^3_i, and omega = 0 1.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKSymmetricProjection-Union{Tuple{T}, Tuple{Any,Tableau{T},Tableau{T}}, Tuple{Any,Tableau{T},Tableau{T},Any}} where T","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKSymmetricProjection","text":"Consider a symplectic pair of tableaus (a^1 b^1 c^1) and (a^3 b^3 c^3), i.e., satsifying b^1_i b^3_j = b^1_i a^3_ij + b^3_j a^1_ji, with an arbitrary number of stages s. For the projection, choose the tableau with tildes = 2 and rho = 1, such that tildeQ_n1 = q_n, tildeQ_n2 = q_n+1, tildeP_n1 = p_n, tildeP_n2 = p_n+1, i.e.,\n\nbeginaligned\nbeginarrayccc\n0  0 \n1  b^1 \nhline\ntildea^1  \nendarray\n\nbeginarrayccc\n 0  0 \n tfrac12  tfrac12 \nhline\ntildea^2  tfrac12  tfrac12 \nendarray\n\nbeginarrayccc\n0  0 \n1  b^3 \nhline\ntildea^3  \nendarray\n\nbeginarrayccc\n 0  0 \n tfrac12  tfrac12 \nhline\ntildea^4  tfrac12  tfrac12 \nendarray\nendaligned\n\nThe coefficients a^2 and a^4 are determined by the symplecticity conditions, specifically a^4_ij = b^4_j ( b^1_i - tildea^1_ji)  b^1_i and a^2_ij = b^2_j ( b^3_i - tildea^3_ji )  b^3_i. Further choose omega = 1 1 0 and delta = -1 R_infty, so that tildeLambda_n1 = R_infty tildeLambda_n2 and\n\ntildeP_n1 - vartheta (tildeQ_n1) + R_infty ( tildeP_n2 - vartheta (tildeQ_n2) ) = 0 \n\nDue to the particular choice of projective stages, this is equivalent to\n\np_n - vartheta (q_n) + R_infty ( p_n+1 - vartheta (q_n+1) ) = 0 \n\nso that the constraint phi(q_n+1 p_n+1) = 0 is satisfied if phi(q_n p_n) = 0. Note that the choice of tildea^2 and tildea^4 violates the symplecticity condition b^2_i b^4_j = b^2_i tildea^4_ij + b^4_j tildea^2_ji.\n\n\n\n\n\n","category":"method"},{"location":"integrators/splitting/#Splitting-and-Composition-Methods","page":"Splitting","title":"Splitting and Composition Methods","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"GeometricIntegrators supports splitting and composition methods, where the solution to an ODE of the form","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"dotx = v_1 (tx) +  + v_r (tx)","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"is obtained by consecutively integrating each vector field v_i independently and combining the resulting solutions in an appropriate way. Consider a simple ODE dotx = V where the vector field v can be written as V = sum_i v_i. The flow (exact solution) of this ODE is","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"x(t) = phi_t (x(0)) = exp(t V) (x(0)) ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"and the composition method ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"varphi_tau = exp(tau v_1) exp(tau v_2) dotsc exp(tau v_r) ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"where tau denotes the time step, provides a first-order accurate approximation to the exact flow as","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"phi_tau = exp bigg( tau sum_i v_i bigg) + mathcalO (tau^2) ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"In the following, we use \"splitting methods\" to denote integrators that utilize the exact solution of each vector field v_i and \"composition methods\" to denote integrators that utilize some consistent but possibly approximate solution for each of the vector fields v_i, i.e., that solution can be exact or obtained by some other integrator. For reference see the excellent review paper by Robert I. McLachlan , G. Reinout W. Quispel  (2002) or the canonical book on Geometric Numerical Integration by Ernst Hairer , Christian Lubich , Gerhard Wanner  (2006).","category":"page"},{"location":"integrators/splitting/#Splitting-of-Hamiltonian-Systems","page":"Splitting","title":"Splitting of Hamiltonian Systems","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"For Hamiltonian systems, splitting is a simple and versatile technique for the construction of symplectic integrators. Suppose that the Hamiltonian H can be split into the sum of r geq 2 Hamiltonians H_i with 1 leq i leq r, i.e.,","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"H (z) = sum limits_i=1^r H_i (z) ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"with each Hamiltonian vector field","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"dotz = Omega^-T  nabla H_i (z) ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"explicitly solvable. The exact solution phi_t^H_i of each subsystem provides a symplectic map. As the composition of symplectic maps yields a symplectic map, a symplectic integrator can be obtained by an appropriate composition of the flow maps of each subsystem. A first-order symplectic integrator is obtained from the Lie-Trotter splitting,","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"varphi_tau = phi_tau^H_1 circ phi_tau^H_2 circ dotsc circ phi_tau^H_k ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Second-order symplectic integrators are obtained from symmetric splittings,","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"varphi_tau = phi_h2^H_1 circ phi_h2^H_2 circ dotsc circ phi_h2^H_k-1 circ phi_tau^H_k circ phi_h2^H_k-1 circ dotsc circ phi_h2^H_2 circ phi_h2^H_1 ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"or","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"varphi_tau = phi_h2^H_k circ phi_h2^H_k-1 circ dotsc circ phi_h2^H_2 circ phi_tau^H_1 circ phi_h2^H_2 circ dotsc circ phi_h2^H_k-1 circ phi_h2^H_k ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Higher order integrators can be constructed by using the Baker-Campbell-Hausdorff formula.","category":"page"},{"location":"integrators/splitting/#Separable-Hamiltonian-Systems","page":"Splitting","title":"Separable Hamiltonian Systems","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"If we have a Hamiltonian of the form H(pq) = T(p) + U(q), we can consider only the subsystem with Hamiltonian U(q),","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\ndotq = 0  \ndotp = - nabla U(q) \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"This system can be solved exactly. The exact flow is","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"phi^U_t (qp) = beginpmatrix\nq \np - t nabla U(q)\nendpmatrix ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Next, consider the subsystem with Hamiltonian T(p) = tfrac12 p^T M^-1 p, ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\ndotq = M^-1 p  \ndotp = 0  \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"This system can be solved exactly as well. The exact flow is","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"phi^T_t (qp) = beginpmatrix\nq + t M^-1 p \np\nendpmatrix ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"As phi^U_t and phi^T_t are exact flows of the respective Hamiltonian, they are both symplectic. We see that the compositions of phi^U_t and phi^T_t correspond to the symplectic Euler methods for separable Hamiltonians,","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\nvarphi^A_tau = phi^U_tau circ phi^T_tau  \nvarphi^B_tau = phi^T_tau circ phi^U_tau \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"where varphi^A_tau and varphi^B_tau denote the numerical flows of symplectic Euler-A and symplectic Euler-B, respectively. As the Störmer-Verlet methods are compositions of the symplectic Euler methods, they are also splitting methods, corresponding to the compositions","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\nvarphi_tau^SV1 = varphi^A_h2 circ varphi^B_h2 = phi^U_h2 circ phi^T_tau circ phi^U_h2  \nvarphi_tau^SV2 = varphi^B_h2 circ varphi^A_h2 = phi^T_h2 circ phi^U_tau circ phi^T_h2 \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"respectively. This particular splitting is often referred to as Strang splitting [Gilbert Strang  (1968), see also Gurij Ivanovich Marchuk  (1968)].","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Let us note that not all symplectic integrators can be obtained as splitting methods. For the symplectic Euler methods and the Störmer-Verlet methods, this is only possible for separable Hamiltonian systems. For general Hamiltonians, these methods cannot be obtained from any splitting but are nevertheless symplectic.","category":"page"},{"location":"integrators/splitting/#Fourth-Order-Methods","page":"Splitting","title":"Fourth Order Methods","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"The general form of a fourth order symplectic integrator for separable Hamiltonian systems is given by","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\nq_1 = q_0 + b_1 tau  T_p (p_0)  \np_1 = p_0 - hatb_1 tau  U_q (q_1)  \nq_2 = q_1 + b_2 tau  T_p (p_1)  \np_2 = p_1 - hatb_2 tau  U_q (q_2)  \nq_3 = q_2 + b_3 tau  T_p (p_2)  \np_3 = p_2 - hatb_3 tau  U_q (q_3)  \nq_4 = q_3 + b_4 tau  T_p (p_3)  \np_4 = p_3 - hatb_4 tau  U_q (q_4) \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"The quantities (q_0 p_0) are initial values and (q_4 p_4) are the numerical solution after one time step tau. The whole algorithm can be written as","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\nvarphi_tau = \nvarphi_hatb_4 tau^U\ncirc\nvarphi_b_4 tau^T\ncirc\nvarphi_hatb_3 tau^U\ncirc\nvarphi_b_3 tau^T\ncirc\nvarphi_hatb_2 tau^U\ncirc\nvarphi_b_2 tau^T\ncirc\nvarphi_hatb_1 tau^U\ncirc\nvarphi_b_1 tau^T\nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"and is therefore immediately seen to be symplectic. Two methods of fourth order are given by","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\nb_1 = b_4 = dfrac12 (2 - gamma)  \nb_2 = b_3 = dfrac1-gamma2 (2 - gamma)  \nhatb_1 = hatb_3 = dfrac12 - gamma  \nhatb_2 = - dfracgamma2 - gamma  \nhatb_4 = 0 \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"and","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\nb_1 = 0  \nb_2 = b_4 = dfrac12 - gamma  \nb_3 = dfrac11 - gamma^2  \nhatb_1 = hatb_4 = tfrac16 (2 + gamma + gamma^-1)  \nhatb_2 = hatb_3 = tfrac16 (2 - gamma - gamma^-1) \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"where gamma = 2^13. Both methods are explicit and symmetric as either varphi_hatb_4 tau^U or varphi_b_1 tau^T corresponds to the identity.","category":"page"},{"location":"integrators/splitting/#Higher-Order-Methods-by-Composition","page":"Splitting","title":"Higher Order Methods by Composition","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"The composition of a one-step symplectic integrator varphi_tau with different step sizes provides a simple way of obtaining higher order schemes. We assume that the initial scheme varphi_tau is symmetric, that is","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"varphi_tau circ varphi_-tau = mathrmid ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"as this simplifies the construction. A symmetric method can always be built by combining a non-symmetric method with its adjoint. If a numerical method varphi_tau is symmetric, it can be used to compose higher order methods by splitting up each timestep into s substeps [Ernst Hairer , Christian Lubich , Gerhard Wanner  (2006), Robert I. McLachlan  (1995), Matthew Marsden Jerrold E. AND West (2001)],","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"varphi_tau = varphi_gamma_s tau circ  circ varphi_gamma_i tau circ  circ varphi_gamma_1 tau ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"where the careful selection of the gamma_i is crucial for the performance of the resulting scheme. In the following, we present some fourth and sixth order composition methods that can be applied in most situations.","category":"page"},{"location":"integrators/splitting/#Fourth-Order-Composition-Methods","page":"Splitting","title":"Fourth Order Composition Methods","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"If varphi_tau is a method of order r, a method hatvarphi_tau of order r+2 is obtained by the composition [Ernst Hairer , Christian Lubich , Gerhard Wanner  (2006), Section V.3.2]","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\nhatvarphi_tau = varphi_gamma tau circ varphi_(1-2gamma) tau circ varphi_gamma tau \n textwith \ngamma = (2 - 2^1(r+1))^-1  \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Hence, if varphi_tau is of second order, the resulting method hatvarphi_tau will be of fourth order. Note that symmetric methods are always of even order. A method of the same order but with generally smaller errors is obtained by considering five steps","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\nhatvarphi_tau = varphi_gamma tau circ varphi_gamma tau circ varphi_(1-4gamma) tau circ varphi_gamma tau circ varphi_gamma tau \n textwith \ngamma = (4 - 4^1(r+1))^-1  \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Multiple application of these compositions yields methods of orders higher than four.","category":"page"},{"location":"integrators/splitting/#Sixth-Order-Composition-Methods","page":"Splitting","title":"Sixth Order Composition Methods","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Higher order compositions can also be constructed directly [Ernst Hairer , Christian Lubich , Gerhard Wanner  (2006), Section V.3.2]. A sixth order method with seven substeps is given by","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\ngamma_1 = gamma_7 = + 078451361047755726381949763  \ngamma_2 = gamma_6 = + 023557321335935813368479318  \ngamma_3 = gamma_5 = - 117767998417887100694641568  \ngamma_4 = + 131518632068391121888424973 \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"but again smaller errors can be achieved by using nine steps","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\ngamma_1 = gamma_9 = + 039216144400731413927925056  \ngamma_2 = gamma_8 = + 033259913678935943859974864  \ngamma_3 = gamma_7 = - 070624617255763935980996482  \ngamma_4 = gamma_6 = + 008221359629355080023149045  \ngamma_5 = + 079854399093482996339895035 \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"The computational effort of these high order methods is quite large. Each step requires the solution of a nonlinear system of equations. Given the outstanding performance already second order symplectic integrators are able to deliver, the necessity for such high order methods is rarely found. Nevertheless, if extremely high accuracy is indispensable, think for example of long-time simulations of the solar system, these methods can be applied. Moreover, there exist special methods optimized for such problems.","category":"page"},{"location":"integrators/splitting/#Splitting-Integrators","page":"Splitting","title":"Splitting Integrators","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"In GeometricIntegrators, basic splitting methods are implemented in IntegratorSplitting, which has two constructors:","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"IntegratorSplitting{DT,D}(solutions::Tuple, f::Vector{Int}, c::Vector, Δt)\nIntegratorSplitting(equation::SODE, tableau::AbstractTableauSplitting, Δt)","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"In the first constructor, DT is the data type of the state vector and D the dimension of the system. In the second constructor, this information is extracted from the equation.  The tuple solutions contains functions implementing the flow (exact solution) of the vector fields v_i. The vectors f and c define the actual splitting method: f is a vector of indices of the flows in the split equation to be solved and c is a vector of the same size f that contains the coefficients for each splitting step, i.e., the resulting integrator has the form","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"varphi_tau = phi_cs tau^v_fs circ dotsc circ phi_c2 tau^v_f2 circ phi_c1 tau^v_f1 ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"In the second constructor, these vectors are constructed from the tableau and the equation.","category":"page"},{"location":"integrators/splitting/#Composition-Integrators","page":"Splitting","title":"Composition Integrators","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Fully flexible composition methods are implemented in IntegratorComposition, which can use any ODE integrator implemented in GeometricIntegrators to solve the steps of the splitting. For each step, a different integrator can be chosen as well as the exact solution using IntegratorExactODE, which is a simple wrapper around the exact flow of a splitting step, implementing the general integrator interface.","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"IntegratorComposition has three constructors:","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"IntegratorComposition{DT,D}(integrators::Tuple, Δt)\nIntegratorComposition(equation::SODE, constructors::Tuple, tableau::AbstractTableauSplitting, Δt)\nIntegratorComposition(equation::SODE, tableau::AbstractTableauSplitting, Δt)","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"In the first constructor, DT is the data type of the state vector and D the dimension of the system. In the second and third constructor, this information is extracted from the equation.  The tuple integrators contains the integrators for each substep. Each integrator is instantiated with appropriately scaled time step size Delta t = c_i tau to match the corresponding splitting scheme. In the second constructor, the tuple constructors contains closures around the constructors for the integrators of each step of the composition, that is functions taking a vector field v_i, the time step Delta t and optional keyword arguments, e.g. for the exact solution or a Runge-Kutta integrator, we have","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"(v::Function, Δt::Number; kwargs...) -> IntegratorExactODE{DT,D}(v, Δt; kwargs...)\n(v::Function, Δt::Number; kwargs...) -> Integrator{DT,D}(v, tableau, Δt; kwargs...)","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"The integrators are constructed according to the tableau and time step \\Delta t and passed to the first constructor. The third constructor assumes that the exact solution is used for each splitting step. It thus constructs a composition method that is equivalent to a plain IntegratorSplitting.","category":"page"},{"location":"integrators/splitting/#Splitting-Tableaus","page":"Splitting","title":"Splitting Tableaus","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Actualy splitting methods are usually prescribed in one of the following forms.","category":"page"},{"location":"integrators/splitting/#[TableauSplitting](@ref)","page":"Splitting","title":"TableauSplitting","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Tableau for general splitting methods for vector fields with two terms v = v_A + v_B, leading to the following integrator:","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"varphi_tau = varphi_b_s tau^B circ varphi_a_s tau^A circ dotsc circ varphi_b_1 tau^B circ varphi_a_1 tau^A ","category":"page"},{"location":"integrators/splitting/#[TableauSplittingNS](@ref)","page":"Splitting","title":"TableauSplittingNS","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Tableau for non-symmetric splitting methods [Robert I. McLachlan , G. Reinout W. Quispel  (2002), Equation (4.10)]. Here, two flows varphi_tau^A and varphi_tau^B are constructed as the Lie composition of all vector fields in the SODE and its adjoint, respectively, i.e..","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\nvarphi_tau^A = varphi_tau^v_1 circ varphi_tau^v_2 circ dotsc circ varphi_tau^v_r-1 circ varphi_tau^v_r  \nvarphi_tau^B = varphi_tau^v_r circ varphi_tau^v_r-1 circ dotsc circ varphi_tau^v_2 circ varphi_tau^v_1 \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"and the integrator is composed as follows:","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"varphi_tau^NS = varphi_b_s tau^B circ varphi_a_s tau^A circ dotsc circ varphi_b_1 tau^B circ varphi_a_1 tau^A ","category":"page"},{"location":"integrators/splitting/#[TableauSplittingGS](@ref)","page":"Splitting","title":"TableauSplittingGS","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Tableau for symmetric splitting methods with general stages [Robert I. McLachlan , G. Reinout W. Quispel  (2002), Equation (4.11)], where again two flows varphi_tau^A and varphi_tau^B are constructed via Lie composition","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\nvarphi_tau^A = varphi_tau^v_1 circ varphi_tau^v_2 circ dotsc circ varphi_tau^v_r-1 circ varphi_tau^v_r  \nvarphi_tau^B = varphi_tau^v_r circ varphi_tau^v_r-1 circ dotsc circ varphi_tau^v_2 circ varphi_tau^v_1 \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"but with an integrator composed as","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"varphi_tau^GS = varphi_a_1 tau^A circ varphi_b_1 tau^B circ dotsc circ varphi_b_1 tau^B circ varphi_a_1 tau^A ","category":"page"},{"location":"integrators/splitting/#[TableauSplittingSS](@ref)","page":"Splitting","title":"TableauSplittingSS","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Tableau for symmetric splitting methods with symmetric stages [Robert I. McLachlan , G. Reinout W. Quispel  (2002), Equation (4.6)]. Here, only one flow varphi_tau^S is constructed via symmetric Strang composition,","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"varphi_tau^S = varphi_tau2^v_1 circ varphi_tau2^v_2 circ dotsc circ varphi_tau2^v_r-1 circ varphi_tau2^v_r circ varphi_tau2^v_r circ varphi_tau2^v_r-1 circ dotsc circ varphi_tau2^v_2 circ varphi_tau2^v_1 ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"and composed as","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"varphi_tau^SS = varphi_a_1 tau^S circ varphi_a_2 tau^S circ dotsc circ varphi_a_s tau^S circ dotsc circ varphi_a_2 tau^S circ varphi_a_1 tau^S ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"to obtain an integrator.","category":"page"},{"location":"modules/simulations/#Simulations","page":"Simulations","title":"Simulations","text":"","category":"section"},{"location":"modules/simulations/","page":"Simulations","title":"Simulations","text":"Modules = [GeometricIntegrators.Simulations]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"modules/simulations/#GeometricIntegrators.Simulations.ParallelSimulation","page":"Simulations","title":"GeometricIntegrators.Simulations.ParallelSimulation","text":"ParallelSimulation: collects all data structures that are necessary for a    simulation run in parallel.\n\nWARNING: Many integrators are not thread-safe at this point!\n\n\n\n\n\n","category":"type"},{"location":"bibliography/#Bibliography","page":"Bibliography","title":"Bibliography","text":"","category":"section"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"","category":"page"},{"location":"integrators/cgvi/#Continuous-Galerkin-Variational-Integrators","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"","category":"section"},{"location":"integrators/spark/","page":"SPARK","title":"SPARK","text":"CurrentModule = GeometricIntegrators.Integrators.SPARK","category":"page"},{"location":"integrators/spark/#Special-Partitioned-Additive-Runge-Kutta-Integrators","page":"SPARK","title":"Special Partitioned Additive Runge-Kutta Integrators","text":"","category":"section"},{"location":"integrators/spark/","page":"SPARK","title":"SPARK","text":"SPARK or Special Partitioned Additive Runge-Kutta Integrators are a family of integrators that have been introduced by Laurent O. Jay for the integration of differential algebraic equations and in particular systems subject to holonomic and nonholonomic constraints [Laurent O. Jay  (1998), Laurent O. Jay  (2003), Laurent O. Jay  (2006), Laurent O. Jay  (2007), Laurent O. Jay  (2007)]. Recently, the idea of SPARK methods has been generalized and adapted to facilitate the integration of degenerate Lagrangian systems as well as Hamiltonian systems subject to Dirac constraints [Michael Kraus  (2020)].","category":"page"},{"location":"integrators/spark/","page":"SPARK","title":"SPARK","text":"GeometricIntegrators.jl provides several flavours of such SPARK methods (some are still experimental):","category":"page"},{"location":"integrators/spark/","page":"SPARK","title":"SPARK","text":"Integrator Description\nIntegratorHPARK Partitioned additive methods for Hamiltonian system subject to a general constraint phi(qp) = 0\nIntegratorVPARK Partitioned additive methods for Lagrangian system subject to a general constraint phi(qp) = 0\nIntegratorSPARK SPARK methods for general index-two differential algebraic equations\nIntegratorHSPARK Hamiltonian system subject to a general constraint phi(qp) = 0\nIntegratorHSPARKprimary Hamiltonian system subject primary constraint in the sense of Dirac\nIntegratorHSPARKsecondary Hamiltonian system enforcing primary & secondary Dirac constraint\nIntegratorVSPARK Lagrangian system in implicit form subject to a general constraint phi(qp) = 0\nIntegratorVSPARKprimary Degenerate Lagrangian system subject primary constraint in the sense of Dirac\nIntegratorVSPARKsecondary Degenerate Lagrangian system enforcing primary & secondary Dirac constraint","category":"page"},{"location":"integrators/spark/","page":"SPARK","title":"SPARK","text":"These integrators are applied to either an IDAE, HDAE or VDAE.","category":"page"}]
}
